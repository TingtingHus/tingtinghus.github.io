<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AB-testing</title>
      <link href="2021/02/22/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9AAB%20testing%20%E6%A6%82%E8%AE%BA/"/>
      <url>2021/02/22/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9AAB%20testing%20%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是极客时间平台课程《A/B测试从0到1》的学习笔记。</em></strong></p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>A/B 测试是促进业务持续增长的最实用、最有效的方式。</p><p>看一个公司或者团队是不是真正做到了数据驱动，就要看它的决策流程中有没有 A/B 测试这一环节。只有在决策流程中加入 A/B 测试这个环节，根据值得信赖的测试结果，而不是所谓的经验来做业务和产品决策时，才是真正的数据驱动决策。</p><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/ABtest%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="AB测试可以解决哪些业务问题.png"></p><h1 id="统计基础"><a href="#统计基础" class="headerlink" title="统计基础"></a>统计基础</h1><h2 id="统计量"><a href="#统计量" class="headerlink" title="统计量"></a>统计量</h2><h3 id="指标的统计属性，指的是什么？"><a href="#指标的统计属性，指的是什么？" class="headerlink" title="指标的统计属性，指的是什么？"></a>指标的统计属性，指的是什么？</h3><p>在实际业务中，我们常用的指标其实就是两类：</p><blockquote><p>均值类的指标，比如用户的平均使用时长、平均购买金额、平均购买频率，等等。<br>概率类的指标，比如用户点击的概率（点击率）、转化的概率（转化率）、购买的概率（购买率），等等。</p></blockquote><p>在数量足够大时，均值类指标服从正态分布；概率类指标本质上服从二项分布，但当数量足够大时，也服从正态分布。</p><p>在二项分布中，有一个从实践中总结出的经验公式：min(np,n(1-p)) &gt;= 5。其中，n 为样本大小，p 为概率的平均值。这个公式的意思是说，np 或者 n(1-p) 中相对较小的一方大于等于 5，只有二项分布符合这个公式时，才可以近似于正态分布。这是中心极限定理在二项分布中的变体。</p><p>有了中心极限定理，我们就可以把业务中的大部分指标都近似成正态分布了。这一点非常重要，因为 A/B 测试中的很多重要步骤，比如计算样本量大小和分析测试结果，都是以指标为正态分布为前提的。</p><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><p>在 A/B 测试的实践中，更推荐使用双尾检验。<br>在 A/B 测试中，使用双样本检验。</p><p>根据样本组不同还可以分为</p><ol><li>当两组样本数据进行比较时，就用双样本检验。比如 A/B 测试中实验组和对照组的比较。</li><li>当一组样本数据和一个具体数值进行比较时，就用单样本检验。比如，我想比较极客时间用户的日均使用时间有没有达到 15 分钟，这个时候，我就可以把一组样本数据（抽样所得的极客时间用户的每日使用时间）和一个具体数值（15）来进行比较。</li><li>当比较同一组样本数据发生变化前和发生变化后时，就用配对检验。比如，我现在随机抽取 1000 个极客时间的用户，给他们“全场专栏一律 1 折”这个优惠，然后在这 1000 个人中，我们会比较他们在收到优惠前一个月的日均使用时间，和收到优惠后一个月的日均使用时间。</li></ol><h3 id="选择T检验还是Z检验"><a href="#选择T检验还是Z检验" class="headerlink" title="选择T检验还是Z检验"></a>选择T检验还是Z检验</h3><p>选择 T 检验还是 Z 检验，主要看样本量的大小和是否知道总体方差（Population Variance）：</p><blockquote><p>当我们不知道总体方差时，使用 T 检验。当我们已知总体方差，且样本量大于 30 时，使用 Z 检验<br>z检验可以视为大样本条件下的t检验的特殊形式。</p></blockquote><p>补充F检验：方差分析就是对试验数据进行分析，检验方差相等的多个正态总体均值是否相等，进而判断各因素对试验指标的影响是否显著。即F检验时检验多个样本(n&gt;2)是否服从同一正态总体，F统计量为组间方差/组内方差。F检验是检验整个方程，即所有解释变量联合起来对被解释变量的影响，但并未说明各个解释变量对被解释变量的影响。而t检验是检验其他解释变量不变时，单个解释变量对被解释变量的影响。</p><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C.png" alt="假设检验.png"></p><p>一个经验就是：</p><blockquote><p>均值类指标一般用 T 检验，概率类指标一般用 Z 检验（比例检验）。</p></blockquote><p>为什么？<br>样本量大的情况下均值类指标是正态分布，正态分布的总体方差的计算需要知道总体中各个数据的值，这在现实中几乎做不到，因为我们能获取的只是样本数据。所以总体方差不可知，选用 T 检验。概率类指标是二项分布，二项分布的总体方差的计算不需要知道总体中各个数据的值，可以通过样本数据求得总体方差。而且现实中 A/B 测试的样本量一般都远大于 30，所以选用 Z 检验。这里的比例检验（Proportion Test) 是，专指用于检验概率类指标的 Z 检验。</p><p>补充：假设检验的基本步骤</p><blockquote><p>（1）确定假设<br>（2）选择检验统计量<br>（3）确定拒绝域<br>（4）求出P值（小于或者等于拒绝域向上的一个样本数值的概率）<br>（5）判断样本结果是否位于拒绝域中<br>（6）做出决策</p></blockquote><h3 id="AB测试的可能结果"><a href="#AB测试的可能结果" class="headerlink" title="AB测试的可能结果"></a>AB测试的可能结果</h3><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/AB%E5%8F%AF%E8%83%BD%E7%BB%93%E6%9E%9C.png" alt="AB测试的可能结果.png"></p><p>发生第一类错误的概率用α表示，也被称为显著水平（Significance Level）。“显著”是指错误发生的概率大，统计上把发生率小于 5% 的事件称为小概率事件，代表这类事件不容易发生。因此显著水平一般也为 5%</p><p>如何通过假设检验得到测试结果呢?<br>实践中常用的有两种方法：P 值（P Value）法和置信区间（Confidence Interval）法。</p><p>如果我们在 A/B 测试中观测到“实验组和对照组指标不同”的概率（P 值）很小，比如小于 5%，是个小概率事件，虽然这在零假设成立时不太可能发生，但是确实被我们观测到了，所以肯定是我们的零假设出了问题。那么，这个时候就应该拒绝零假设，接受备择假设，即两组指标是不同的.<br>与此相反的是，当我们在 A/B 测试中观测到“实验组和对照组指标不同”的概率（P 值）很大，比如 70%，那么在零假设成立时，我们观测到这个事件还是很有可能的。所以这个时候我们接受零假设，拒绝备择假设，即两组指标是相同的。</p><blockquote><p>当 P 值小于 5% 时，我们拒绝零假设，接受备择假设，得出两组指标是不同的结论，又叫做结果显著。<br>当 P 值大于 5% 时，我们接受零假设，拒绝备择假设，得出两组指标是相同的结论，又叫做结果不显著。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>对于 A/B 测试来说，要选用双尾、双样本的比例检验（概率类指标）或 T 检验（均值类指标）。这决定了你在计算分析 A/B 测试结果时如何选取检验的参数，所以很重要</li><li>在 A/B 测试实践中，计算样本量大小、指标波动性和分析测试结果的时候，会用到这些统计概念。</li><li>计算样本量大小时，会用到： 第一类 / 第二类错误及其概率α和β。</li><li>计算指标波动性时，会用到：方差和置信区间。</li><li>分析 A/B 测试结果时，会用到：各类检验、置信区间、P 值。</li></ol><p>！<a href="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C.png">假设检验总结.png</a></p><h1 id="AB测试的流程"><a href="#AB测试的流程" class="headerlink" title="AB测试的流程"></a>AB测试的流程</h1><p>最核心的 5 个部分，也就是确定目标和假设、确定指标、确定实验单位、估算样本量以及分析测试结果。<br><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/AB%E6%B5%81%E7%A8%8B.png" alt="AB测试的规范流程"></p><h2 id="确定目标和假设"><a href="#确定目标和假设" class="headerlink" title="确定目标和假设"></a>确定目标和假设</h2><p>举例：付费的音乐 App 要提高营收<br>分析：我们 App 的用户留存率低于行业平均水 ——&gt; 我们的产品在歌曲库的内容和丰富程度上，都在行业平均水平之上，而且 App 的运行也十分流畅，但是缺少一些便利的产品功能 ——&gt; 通过增加产品功能来提升用户留存 ——&gt; 用户只要每个月按时付费续订，就是留存<br>假设：在每个专辑 / 歌单播放完成后增加“自动播放下一个专辑 / 歌单”的功能，可以提升用户下个月的续订率。</p><p>！<a href="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/%E5%A5%BD%E7%9A%84AB%E5%81%87%E8%AE%BE.png">好的AB测试假设是什么.png</a></p><h3 id="A-B-测试的指标有哪几类？"><a href="#A-B-测试的指标有哪几类？" class="headerlink" title="A/B 测试的指标有哪几类？"></a>A/B 测试的指标有哪几类？</h3><p>A/B 测试的指标分为评价指标（Evaluation Metrics）和护栏指标（Guardrail Metrics）这两类。</p><blockquote><p>评价指标，一般指能驱动公司 / 组织实现核心价值的指标，又被称作驱动指标。评价指标通常是短期的、比较敏感、有很强的可操作性，例如点击率、转化率、人均使用时长等<br>护栏指标属于 A/B 测试中基本的合理性检验（Sanity Check），就像飞机起飞前的安全检查一样。它的作用就是作为辅助，来保障 A/B 测试的质量：(1)衡量 A/B 测试是否符合业务上的长期目标，不会因为优化短期指标而打乱长期目标。(2)确保从统计上尽量减少出现各种偏差（Bias），得到尽可能值得信任的实验结果。</p></blockquote><p>用 A/B 测试来检测单次的变化时（比如单次推送 / 邮件）一般选用短期效果的指标，因为长期效果目标通常对单次变化并不敏感。用 A/B 测试来检测连续的、永久的变化时（比如增加产品功能），可以选用长期效果的指标.</p><h3 id="什么样的指标可以作为评价指标？"><a href="#什么样的指标可以作为评价指标？" class="headerlink" title="什么样的指标可以作为评价指标？"></a>什么样的指标可以作为评价指标？</h3><ol><li>可归因性</li><li>可测量性</li><li>敏感性和稳定性 (如果实验中的变量变化了，评价指标要能敏感地做出相应的变化；但如果是其他因素变化了，评价指标要能保持相应的稳定性。)</li></ol><h3 id="怎么判断指标是否具备敏感性和稳定性"><a href="#怎么判断指标是否具备敏感性和稳定性" class="headerlink" title="怎么判断指标是否具备敏感性和稳定性"></a>怎么判断指标是否具备敏感性和稳定性</h3><p>如果选取的评价指标对 A/B 测试中的变化不敏感，或者对其他变化太敏感，我们的实验都会失败。那么，具体该如何测量评价指标的敏感性和稳定性呢？业界通常采用 A/A 测试来测量稳定性，用回溯性分析来表征敏感性。</p><h4 id="AA测试"><a href="#AA测试" class="headerlink" title="AA测试"></a>AA测试</h4><p>和 A/B 测试类似，A/A 测试（A/A Test）也是把被测试对象分成实验组和对照组。但不同的是，A/A 测试中两组对象拥有的是完全相同的体验，如果 A/A 测试的结果发现两组的指标有显著不同，那么就说明要么分组分得不均匀，每组的数据分布差异较大；要么选取的指标波动范围太大，稳定性差。</p><h4 id="回溯性分析"><a href="#回溯性分析" class="headerlink" title="回溯性分析"></a>回溯性分析</h4><p>如果没有之前实验的数据，或者是因为某些原因（比如时间不够）没有办法跑新的实验，那我们也可以通过分析历史数据，进行回溯性分析（Retrospective Analysis）。也就是在分析之前不同的产品变化时，去看我们感兴趣的指标是否有相应的变化。</p><h3 id="如何选取具体的评价指标？"><a href="#如何选取具体的评价指标？" class="headerlink" title="如何选取具体的评价指标？"></a>如何选取具体的评价指标？</h3><ol><li>要清楚业务或产品所处的阶段，根据这个阶段的目标，来确定评价指标。</li><li>如果目标比较抽象，我们就需要采用定性 + 定量相结合的方法了。比如，对于一些比较抽象的目标，比如用户的满意度，我们可以使用一些定性的方法，确定一些假设和想法，像问卷调查、用户调研等</li><li>如果有条件的话，你还可以通过公开或者非公开的渠道，参考其他公司相似的实验或者研究，根据自己的情况去借鉴他们使用的评价指标。</li></ol><h2 id="确定指标"><a href="#确定指标" class="headerlink" title="确定指标"></a>确定指标</h2><h3 id="综合多个指标，建立总体评价标准"><a href="#综合多个指标，建立总体评价标准" class="headerlink" title="综合多个指标，建立总体评价标准"></a>综合多个指标，建立总体评价标准</h3><p>当要考察的事物包含多个方面时，只有综合各方面的指标，才能把握总体的好坏。<br>使用 OEC 的另一个好处就是可以避免多重检验问题（Multiple Testing Problem）。如果我们不把不同的指标加权结合起来分析，而是单独比较它们，就会出现多重检验的问题，导致 A/B 测试的结果不准确。</p><p>需要注意的一点是，不同指标的单位、大小可能不在一个尺度上，需要先要对各个指标进行归一化（Normalization）处理，使它们的取值都在一定的范围内，比如[0,1]， 之后再进行结合，从而剔除指标单位 / 大小的影响。</p><h3 id="如何衡量评价指标的波动性？"><a href="#如何衡量评价指标的波动性？" class="headerlink" title="如何衡量评价指标的波动性？"></a>如何衡量评价指标的波动性？</h3><p>虽然实验组的数据要比对照组的好，但是这些数据都在正常的波动范围内。所以，增加自动播放功能和提升续订率之间的因果关系，在这次实验中就没有被建立起来，因为这两组指标的差异也可能只是正常的波动而已。但是，如果我们事先不知道评价指标的波动性和正常波动范围，就很有可能建立错误的因果关系。</p><p>在统计学里面，指标的波动性通常用其平均值和平均值的标准差来表示，一个指标平均值的标准差越大，说明其波动性越大。这里面要注意，变量平均值的标准差又叫做标准误差。</p><p>对于简单的指标，主要是概率类和均值类，我们可以用统计公式来计算标准误差，对于概率类和均值类，在样本足够大的情况下，服从正态分布，可以直接通过公式计算标准误。<br>但实际中更常用的方法是，构造试验来测量标准误。比如A/A 测试、Bootstrapping 算法</p><h4 id="AA测试-1"><a href="#AA测试-1" class="headerlink" title="AA测试"></a>AA测试</h4><p>我们可以跑多个不同样本大小的 A/A 测试，然后分别计算每个样本的指标大小，计算出来后，再把这些指标从小到大排列起来，并且去除最小 2.5% 和最大 2.5% 的值，剩下的就是 95% 的置信区间</p><h4 id="Bootstrapping-算法"><a href="#Bootstrapping-算法" class="headerlink" title="Bootstrapping 算法"></a>Bootstrapping 算法</h4><p>我们可以先跑一个样本很大的 A/A 测试，然后在这个大样本中进行随机可置换抽样（Random Sample with Replacement）， 抽取不同大小的样本来分别计算指标。然后采用和 A/A 测试一样的流程：把这些指标从小到大排列起来，并且去除最小 2.5% 和最大 2.5% 的值，得到 95% 的置信区间。</p><p>不过要注意的是，即使对于那些简单的、符合正态分布的、可以用统计方法直接计算方差的指标，如果有条件、有时间的话，我也推荐你同时用统计公式和 Bootstrapping 两种方法分别计算方差。如果两者的结果差距较大，就需要再去跑更多的 A/A 测试，所以从两方面验证得到的结果会更保险。</p><h3 id="护栏指标"><a href="#护栏指标" class="headerlink" title="护栏指标"></a>护栏指标</h3><p>A/B 测试往往改变的是业务中的某一部分指标（评价指标），所以我们很容易只关注短期的改变，却失去了对业务的大局观（比如长期的盈利能力 / 用户体验）的掌控或者统计上合理性的检查。因此在实践中，我会推荐每个 A/B 测试都要有相应的护栏指标。</p><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/%E6%8A%A4%E6%A0%8F%E6%8C%87%E6%A0%87.png" alt="护栏指标.png"></p><h4 id="怎么确定AB测试结果是否存在偏差？"><a href="#怎么确定AB测试结果是否存在偏差？" class="headerlink" title="怎么确定AB测试结果是否存在偏差？"></a>怎么确定AB测试结果是否存在偏差？</h4><p>造成偏差的原因有很多，可能是随机分组的算法出现了 Bug，也可能是样本不够大，还有可能是触发实验条件的数据出现了延迟，不过更多的是具体实施中的工程问题造成的。这些偏差都会影响我们获得准确的实验结果，而护栏指标就是我们发现这些偏差的利器</p><h2 id="如何选取合适的实验单位。"><a href="#如何选取合适的实验单位。" class="headerlink" title="如何选取合适的实验单位。"></a>如何选取合适的实验单位。</h2><p>实验单位有哪些？</p><ol><li>用户层面</li><li>访问层面</li><li>页面层面</li></ol><h3 id="用户层面"><a href="#用户层面" class="headerlink" title="用户层面"></a>用户层面</h3>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用机器学习优缺点</title>
      <link href="2021/01/29/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>2021/01/29/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是机器学习笔记的整理<br>参考来源有：<br>1.机器学习算法比较 <a href="http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/">http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/</a><br>2.<a href="https://blog.csdn.net/u010462995/article/details/70312702">https://blog.csdn.net/u010462995/article/details/70312702</a></em></strong></p><table><thead><tr><th align="center">序号</th><th align="center">算法</th><th align="center">模型</th><th align="center">监督学习</th><th align="center">线性</th><th align="center">多分类</th><th align="center">求解算法</th><th align="center">计算复杂度</th><th align="center">解释性</th><th align="center">缺失值影响</th><th align="left">无量纲化的影响</th><th align="left">预处理选择</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">线性回归</td><td align="center">判别</td><td align="center">有</td><td align="center">是</td><td align="center">不支持</td><td align="center">梯度下降法、正规方程解（解析解）</td><td align="center">低</td><td align="center">容易</td><td align="center">敏感</td><td align="left">加快速度</td><td align="left">NA</td><td align="left"></td></tr><tr><td align="center">2</td><td align="center">逻辑回归</td><td align="center">判别</td><td align="center">有</td><td align="center">是</td><td align="center">不支持</td><td align="center">梯度下降法、牛顿法</td><td align="center">低</td><td align="center">容易</td><td align="center">敏感</td><td align="left">加快速度</td><td align="left">标准化</td><td align="left"></td></tr><tr><td align="center">3</td><td align="center">朴素贝叶斯</td><td align="center">生成</td><td align="center">有</td><td align="center">非</td><td align="center">支持</td><td align="center">公式解</td><td align="center">中</td><td align="center">容易</td><td align="center">较不敏感</td><td align="left">NA</td><td align="left">标准化</td><td align="left"></td></tr><tr><td align="center">4</td><td align="center">KNN</td><td align="center">判别</td><td align="center">有</td><td align="center">非</td><td align="center">支持</td><td align="center">Kd树算法</td><td align="center">高</td><td align="center">一般</td><td align="center">一般</td><td align="left">提升精度</td><td align="left">标准化</td><td align="left">NA</td></tr><tr><td align="center">5</td><td align="center">Kmeans</td><td align="center">判别</td><td align="center">无</td><td align="center">非</td><td align="center">支持</td><td align="center">误差平方和最小法</td><td align="center">低</td><td align="center">容易</td><td align="center">一般</td><td align="left">提升精度</td><td align="left">标准化</td><td align="left">不能自动识别类的个数（输入）</td></tr><tr><td align="center">6</td><td align="center">决策树</td><td align="center">判别</td><td align="center">有</td><td align="center">非</td><td align="center">支持</td><td align="center">贪心算法、穷举搜索</td><td align="center">低</td><td align="center">容易</td><td align="center">不敏感</td><td align="left">决策树可以处理任何类型的数据</td><td align="left">标准化</td><td align="left"></td></tr><tr><td align="center">7</td><td align="center">随机森林</td><td align="center">判别</td><td align="center">有</td><td align="center">非</td><td align="center">支持</td><td align="center">贪心算法、穷举搜索</td><td align="center">低</td><td align="center">容易</td><td align="center">不敏感</td><td align="left">NA</td><td align="left">基于bootstrap原理</td><td align="left"></td></tr><tr><td align="center">8</td><td align="center">SVM</td><td align="center">判别</td><td align="center">有</td><td align="center">非</td><td align="center">不直接支持</td><td align="center">SMO算法</td><td align="center">中</td><td align="center">容易</td><td align="center">敏感</td><td align="left">加快速度</td><td align="left">标准化</td><td align="left">基于bootstrap原理</td></tr><tr><td align="center">9</td><td align="center">人工神经网络</td><td align="center">判别</td><td align="center">有</td><td align="center">非</td><td align="center">支持</td><td align="center">梯度下降法、反向传插法</td><td align="center">高</td><td align="center">困难</td><td align="center">不敏感</td><td align="left">加快速度</td><td align="left">标准化</td><td align="left"></td></tr><tr><td align="center">10</td><td align="center">Adaboosting</td><td align="center">判别</td><td align="center">有</td><td align="center">非</td><td align="center">支持</td><td align="center">分阶段优化、公式解</td><td align="center">低</td><td align="center">容易</td><td align="center">不敏感</td><td align="left">NA</td><td align="left">NA</td><td align="left">基于bootstrap原理</td></tr></tbody></table><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>线性回归是用于回归的，它不像Logistic回归那样用于分类，其基本思想是用梯度下降法对最小二乘法形式的误差函数进行优化，当然也可以用normal equation（解方程）直接求得参数的解。</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>实现简单，计算简单；</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>不能拟合非线性数据</p><h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>逻辑回归属于判别式模型，同时伴有很多模型正则化的方法（L0， L1，L2，etc），而且你不必像在用朴素贝叶斯那样担心你的特征是否相关，与决策树、SVM相比，你还会得到一个不错的概率解释，你甚至可以轻松地利用新数据来更新模型（使用在线梯度下降算法-online gradient descent）。如果你需要一个概率架构（比如，简单地调节分类阈值，指明不确定性，或者是要获得置信区间），或者你希望以后将更多的训练数据快速整合到模型中去，可以使用逻辑回归。</p><h2 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h2><p>实现简单，广泛的应用于工业问题上；<br>分类时计算量非常小，速度很快，存储资源低；<br>便利的观测样本概率分数；<br>对逻辑回归而言，多重共线性并不是问题，它可以结合L2正则化来解决该问题；<br>计算代价不高，易于理解和实现；</p><h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><p>当特征空间很大时，逻辑回归的性能不是很好；<br>容易欠拟合，一般准确度不太高<br>不能很好地处理大量多类特征或变量；<br>逻辑斯蒂回归对自变量的多元共线性非常敏感，要求自变量之间相互独立；<br>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；<br>对于非线性特征，需要进行转换；</p><h2 id="logistic回归应用领域："><a href="#logistic回归应用领域：" class="headerlink" title="logistic回归应用领域："></a>logistic回归应用领域：</h2><p>用于二分类领域，可以得出概率值，适用于根据分类概率排名的领域，如搜索排名等<br>Logistic回归的扩展softmax可以应用于多分类领域，如手写字识别等<br>信用评估，是否违约<br>是否为垃圾邮件<br>测量市场营销的成功度<br>预测某个产品的收益</p><h1 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h1><p>KNN即最近邻算法，其主要过程为：</p><ol><li>计算训练样本和测试样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）；</li><li>对上面所有的距离值进行排序(升序)；</li><li>选前k个最小距离的样本；</li><li>根据这k个样本的标签进行投票，得到最后的分类类别；</li></ol><p>如何选择一个最佳的K值，这取决于数据。一般情况下，在分类时较大的K值能够减小噪声的影响，但会使类别之间的界限变得模糊。一个较好的K值可通过各种启发式技术来获取，比如，交叉验证。另外噪声和非相关性特征向量的存在会使K近邻算法的准确性减小。近邻算法具有较强的一致性结果，随着数据趋于无限，算法保证错误率不会超过贝叶斯算法错误率的两倍。对于一些好的K值，K近邻保证错误率不会超过贝叶斯理论误差率.</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>理论成熟，思想简单，既可以用来做分类也可以用来做回归；<br>可用于非线性分类；<br>训练时间复杂度为O(n)；<br>对数据没有假设，准确度高，对outlier异常值不敏感；<br>KNN是一种在线技术，新数据可以直接加入数据集而不必进行重新训练；<br>KNN理论简单，容易实现；</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）效果差；<br>需要大量内存；<br>对于样本容量大的数据集计算量比较大（体现在距离计算上）；<br>样本不平衡时，预测偏差比较大。如：某一类的样本比较少，而其它类样本比较多；<br>KNN每一次分类都会重新进行一次全局运算；<br>k值大小的选择没有理论选择最优，往往是结合K-折交叉验证得到最优k值选择；</p><h2 id="KNN算法应用领域"><a href="#KNN算法应用领域" class="headerlink" title="KNN算法应用领域"></a>KNN算法应用领域</h2><p>文本分类、模式识别、聚类分析，多分类领域</p><h1 id="Kmeans"><a href="#Kmeans" class="headerlink" title="Kmeans"></a>Kmeans</h1><p>是一个简单的聚类算法，把n的对象根据他们的属性分为k个分割，k&lt; n。 算法的核心就是要优化失真函数J,使其收敛到局部最小值但不是全局最小值。<br>不能自动识别类的个数(输入参数是k，即k个类),随机找k个点作为初始中心：c1, c2, … ck，初始聚类中心的选择对聚类结果的影响很大</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>算法简单，容易实现 ；<br>算法速度很快；<br>对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是O(nkt)，其中n是所有对象的数目，k是簇的数目,t是迭代的次数。通常k&lt;&lt;n。这个算法通常局部收敛。<br>算法尝试找出使平方误差函数值最小的k个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>对数据类型要求较高，适合数值型数据；<br>可能收敛到局部最小值，在大规模数据上收敛较慢<br>分组的数目k是一个输入参数，不合适的k可能返回较差的结果。<br>对初值的簇心值敏感，对于不同的初始值，可能会导致不同的聚类结果；<br>不适合于发现非凸面形状的簇，或者大小差别很大的簇。<br>对于”噪声”和孤立点数据敏感，少量的该类数据能够对平均值产生极大影响。</p><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树的一大优势就是易于解释。它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别A在某个特征维度x的末端，类别B在中间，然后类别A又出现在特征维度x前端的情况）。它的缺点之一就是不支持在线学习，于是在新样本到来后，决策树需要全部重建。另一个缺点就是容易出现过拟合，但这也就是诸如随机森林RF（或提升树boosted tree）之类的集成方法的切入点。另外，随机森林经常是很多分类问题的赢家（通常比支持向量机好上那么一丁点），它训练快速并且可调，同时你无须担心要像支持向量机那样调一大堆参数，所以在以前都一直很受欢迎。<br>决策树中很重要的一点就是选择一个属性进行分枝，因此要注意一下信息增益的计算公式，并深入理解它。</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>决策树易于理解和解释，可以可视化分析，容易提取出规则；<br>可以同时处理标称型和数值型数据；<br>比较适合处理有缺失属性的样本；<br>能够处理不相关的特征；<br>测试数据集时，运行速度比较快；<br>在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>容易发生过拟合（随机森林可以很大程度上减少过拟合）；<br>容易忽略数据集中属性的相互关联；<br>对于那些各类别样本数量不一致的数据，在决策树中，进行属性划分时，不同的判定准则会带来不同的属性选择倾向；信息增益准则对可取数目较多的属性有所偏好（典型代表ID3算法），而增益率准则（CART）则对可取数目较少的属性有所偏好，但CART进行属性划分时候不再简单地直接利用增益率尽心划分，而是采用一种启发式规则）（只要是使用了信息增益，都有这个缺点，如RF）。<br>ID3算法计算信息增益时结果偏向数值比较多的特征。</p><h2 id="改进措施"><a href="#改进措施" class="headerlink" title="改进措施"></a>改进措施</h2><p>对决策树进行剪枝。可以采用交叉验证法和加入正则化的方法。<br>使用基于决策树的combination算法，如bagging算法，randomforest算法，可以解决过拟合的问题；</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>企业管理实践，企业投资决策，由于决策树很好的分析能力，在决策过程应用较多。</p><h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><p>随机森林对多元共线性不敏感，结果对缺失数据和非平衡的数据比较稳健，可以很好地预测多达几千个解释变量的作用（Breiman 2001b），被誉为当前最好的算法之一。</p><h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><p>随机森林对<strong>多元共线性不敏感</strong>，结果对<strong>缺失数据</strong>和<strong>非平衡的数据</strong>比较稳健，可以很好地预测多达几千个解释变量的作用。<br>它的学习过程很快。在处理很大的数据时，它依旧非常高效<br>它包含估计缺失值的算法，如果有一部分的资料遗失，仍可以维持一定的准确度。<br>随机森林对<strong>离群值不敏感</strong>，在随机干扰较多的情况下表现稳健。<br>随机森林中分类树的算法自然地包括了变量的交互作用（interaction）（Cutler, etal.，2007），即X1的变化导致X2对Y的作用发生改变。交互作用在其他模型中（如逻辑斯蒂回归）因其复杂性经常被忽略。</p><h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><p>随机森林在解决回归问题时并没有像它在分类中表现的那么好<br>对于许多统计建模者来说，随机森林给人的感觉像是一个黑盒子——你几乎无法控制模型内部的运行，只能在不同的参数和随机种子之间进行尝试<br>是它的算法倾向于观测值较多的类别</p><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>支持向量机，一个经久不衰的算法，高准确率，为避免过拟合提供了很好的理论保证，而且就算数据在原特征空间线性不可分，只要给个合适的核函数，它就能运行得很好。在动辄超高维的文本分类问题中特别受欢迎。可惜内存消耗大，难以解释，运行和调参也有些烦人，而随机森林却刚好避开了这些缺点，比较实用。</p><h2 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h2><p>可以解决高维问题，即大型特征空间；<br>解决小样本下机器学习问题；<br>能够处理非线性特征的相互作用；<br>无局部极小值问题；（相对于神经网络等算法）<br>无需依赖整个数据；<br>泛化能力比较强；</p><h2 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h2><p>当观测样本很多时，效率并不是很高；<br>对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数；<br>对于核函数的高维映射解释力不强，尤其是径向基函数；<br>常规SVM只支持二分类；<br>对缺失数据敏感；<br>对于核的选择也是有技巧的（libsvm中自带了四种核函数：线性核、多项式核、RBF以及sigmoid核）：<br>第一，如果样本数量小于特征数，那么就没必要选择非线性核，简单的使用线性核就可以了；<br>第二，如果样本数量大于特征数目，这时可以使用非线性核，将样本映射到更高维度，一般可以得到更好的结果；<br>第三，如果样本数目和特征数目相等，该情况可以使用非线性核，原理和第二种一样。<br>对于第一种情况，也可以先对数据进行降维，然后使用非线性核，这也是一种方法。</p><h2 id="SVM应用领域"><a href="#SVM应用领域" class="headerlink" title="SVM应用领域"></a>SVM应用领域</h2><p>文本分类、图像识别（主要二分类领域，毕竟常规SVM只能解决二分类问题）</p><h1 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h1><h2 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h2><p>分类的准确度高；<br>并行分布处理能力强,分布存储及学习能力强，<br>对噪声神经有较强的鲁棒性和容错能力；<br>具备联想记忆的功能，能充分逼近复杂的非线性关系；</p><h2 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h2><p>神经网络需要大量的参数，如网络拓扑结构、权值和阈值的初始值；<br>黑盒过程，不能观察之间的学习过程，输出结果难以解释，会影响到结果的可信度和可接受程度；<br>学习时间过长，有可能陷入局部极小值，甚至可能达不到学习的目的。</p><h2 id="人工神经网络应用领域："><a href="#人工神经网络应用领域：" class="headerlink" title="人工神经网络应用领域："></a>人工神经网络应用领域：</h2><p>目前深度神经网络已经应用与计算机视觉，自然语言处理，语音识别等领域并取得很好的效果。</p><h1 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h1><p>Adaboost是一种加和模型，每个模型都是基于上一次模型的错误率来建立的，过分关注分错的样本，而对正确分类的样本减少关注度，逐次迭代之后，可以得到一个相对较好的模型。该算法是一种典型的boosting算法，其加和理论的优势可以使用Hoeffding不等式得以解释。有兴趣的同学可以阅读下自己之前写的这篇文章AdaBoost算法详述.下面总结下它的优缺点。</p><h2 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h2><p>Adaboost是一种有很高精度的分类器。<br>可以使用各种方法构建子分类器，Adaboost算法提供的是框架。<br>当使用简单分类器时，计算出的结果是可以理解的，并且弱分类器的构造极其简单。<br>简单，不用做特征筛选。<br>不易发生overfitting。<br>关于Adaboost, GBDT 及 XGBoost 算法区别，参考这篇文章：Adaboost、GBDT与XGBoost的区别</p><h2 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h2><p>对outlier比较敏感</p><h1 id="其它模型"><a href="#其它模型" class="headerlink" title="其它模型"></a>其它模型</h1><h2 id="当数据存在多重共线性"><a href="#当数据存在多重共线性" class="headerlink" title="当数据存在多重共线性"></a>当数据存在多重共线性</h2><p>在回归分析中，当自变量之间出现多重共线性现象时，常会严重影响到参数估计，扩大模型误差，并破坏模型的稳健性，因此消除多重共线性成为回归分析中参数估计的一个重要环节。现在常用的解决多元线性回归中多重共线性的回归模型有岭回归（Ridge Regression）、主成分回归(Principal Component Regression简记为PCR)和偏最小二乘回归(Partial Least Square Regression简记为PLS)。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎样评价模型的好坏</title>
      <link href="2021/01/27/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E6%80%8E%E6%A0%B7%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%9D%8F/"/>
      <url>2021/01/27/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E6%80%8E%E6%A0%B7%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%9D%8F/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是机器学习模型评价指标的整理笔记，主要参考来源有<br>1.机器学习分类器模型评价指标 <a href="https://blog.csdn.net/login_sonata/article/details/54288653">https://blog.csdn.net/login_sonata/article/details/54288653</a><br>2.机器学习分类模型评价指标详述 <a href="https://zhuanlan.zhihu.com/p/43405406">https://zhuanlan.zhihu.com/p/43405406</a></em></strong></p><h1 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h1><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><h3 id="残差SS，残差平方和RSS"><a href="#残差SS，残差平方和RSS" class="headerlink" title="残差SS，残差平方和RSS"></a>残差SS，残差平方和RSS</h3><p>残差SS是实际观测值和模型估计值之差，残差越大，预测效果越不好<br>实际应用中多使用残差平方和RSS，残差平方和越小，模型拟合效果越好。**<em>较常用**</em></p><h3 id="均方误差（MSE）"><a href="#均方误差（MSE）" class="headerlink" title="均方误差（MSE）"></a>均方误差（MSE）</h3><p>MSE （Mean Squared Error）叫做均方误差，用（ 真实值-预测值 ）然后平方之后求和平均，也就是线性回归的损失函数，在线性回归的时候我们的目的就是让这个损失函数最小。</p><h3 id="均方根误差（RMSE）"><a href="#均方根误差（RMSE）" class="headerlink" title="均方根误差（RMSE）"></a>均方根误差（RMSE）</h3><p>即MSE开个根号么，其实实质是一样的，只不过用于数据更好的描述。<br>例如：要做房价预测，每平方是万元（真贵），我们预测结果也是万元。那么差值的平方单位应该是 千万级别的，因此最好就开个根号，我们误差的结果就跟我们数据是一个级别的了。</p><h3 id="平均绝对误差-MAE）"><a href="#平均绝对误差-MAE）" class="headerlink" title="平均绝对误差(MAE）"></a>平均绝对误差(MAE）</h3><p>MAE用来衡量预测值与真实值之间的平均绝对误差，MAE越小表示模型越好</p><h3 id="R-Squared"><a href="#R-Squared" class="headerlink" title="R Squared"></a>R Squared</h3><p>1 -（均方误差MSE/方差），R Squared已进行了归一化，更容易看出模型间的差距。**<em>是最常用的评价指标**</em></p><p>分子均方误差MS:就是我们训练出的模型预测的所有误差。【（ 真实值-预测值 ）然后平方之后求和平均】<br>分母方差:就是不管什么我们猜的结果就是y的平均数。（瞎猜的误差）</p><p>如果结果是0，就说明我们的模型跟瞎猜差不多；<br>如果结果是1，就说明我们模型无错误；<br>如果结果是0-1之间的数，就是我们模型的好坏程度；<br>如果结果是负数，说明我们的模型还不如瞎猜。（其实导致这种情况说明我们的数据其实没有啥线性关系）</p><h3 id="AIC和BIC"><a href="#AIC和BIC" class="headerlink" title="AIC和BIC"></a>AIC和BIC</h3><h3 id="显著性"><a href="#显著性" class="headerlink" title="显著性"></a>显著性</h3><p>可以利用假设检验判断系数是否显著，系数如果都不显著，说明模型不好。**<em>通常用于已知模型，判断因变量与自变量的相关性**</em></p><h3 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h3><p>这种方法将数据分成K个部分，把其中一格部分用作测试集，其余部分用作训练集以拟合模型。模型拟合好之后，使用测试集进行测试，并计算误差。不断重复这个过程，直到K个部分都测试过。模型最终的误差是所有模型的平均值。**<em>不太常用**</em></p><h2 id="图形评价"><a href="#图形评价" class="headerlink" title="图形评价"></a>图形评价</h2><h3 id="画预测值和真实值图形"><a href="#画预测值和真实值图形" class="headerlink" title="画预测值和真实值图形"></a>画预测值和真实值图形</h3><p>最简单直接的方法是画出预测点与真实点的图形，评价预测效果</p><h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>学习曲线时，横轴为训练样本的数量，纵轴为准确率。学习曲线就是通过画出不同训练集大小时训练集和交叉验证的准确率，可以看到模型在新数据上的表现，进而来判断模型是否方差偏高或偏差过高，以及增大训练集是否可以减小过拟合。</p><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/image.png" alt="学习曲线.png"></p><p>当训练集和测试集的误差收敛但却很高时，为高偏差。<br>左上角的偏差很高，训练集和验证集的准确率都很低，很可能是欠拟合。我们可以增加模型参数，比如，构建更多的特征，减小正则项。 此时通过增加数据量是不起作用的。</p><p>当训练集和测试集的误差之间有大的差距时，为高方差。<br>当训练集的准确率比其他独立数据集上的测试结果的准确率要高时，一般都是过拟合。我们可以增大训练集，降低模型复杂度，增大正则项，或者通过特征选择减少特征数。</p><p>理想情况是是找到偏差和方差都很小的情况，即收敛且误差较小。（右下）</p><h1 id="二分类模型"><a href="#二分类模型" class="headerlink" title="二分类模型"></a>二分类模型</h1><h2 id="混淆矩阵的基本概念"><a href="#混淆矩阵的基本概念" class="headerlink" title="混淆矩阵的基本概念"></a>混淆矩阵的基本概念</h2><p>对于分类模型而言（这里仅以最简单的二分类为例，假设只有0和1两类），最终的判别结果无非就四种情况：实际为0被正确预测为0，实际为0被错误预测为1，实际为1被错误误测为0，实际为1被正确预测为1。<br>以上四类判别结果展示在混淆矩阵上是一个两行两列的交叉矩阵，行分别代表实际的正例和负例，列分别代表预测的正例和负例。</p><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/image.png" alt="混淆矩阵.png"></p><p>那么在以上矩阵中：四个象限分别代表四种判别结果：<br>左上角被称为真阳性（True Positive,TP）:样本实际为正（这里的正负仅仅是相对意义上我们想要研究的类别）例，且模型预测结果为正例；<br>左下角被称为假阴性（False Negative，FN）:样本实际为正例，但模型预测为负例，第二类错误；<br>右上角被称为假阳性（False Positive，FP）：样本实际类别为负例，但模型预测为正例，第一类错误；<br>右下角被称为真阴性（True Negative，TN）：样本实际类别为负例，且模型预测为负例。</p><p>混淆矩阵的四个象限有明显的规律，左上角至右下角的对角线上是预测正确（以T开头），另一条对角线则预测错误（以F开头），左侧上下象限是预测为真的类别（以P结尾），右侧上下象限为预测错误的类别（以N结尾）</p><h2 id="评价指标-1"><a href="#评价指标-1" class="headerlink" title="评价指标"></a>评价指标</h2><h3 id="分类准确率（即所有分类中被正确分类的比例，也称识别率）"><a href="#分类准确率（即所有分类中被正确分类的比例，也称识别率）" class="headerlink" title="分类准确率（即所有分类中被正确分类的比例，也称识别率）"></a>分类准确率（即所有分类中被正确分类的比例，也称识别率）</h3><p>(TP + TN)/(TP + TN + FN + FN)</p><h3 id="召回率-Recall（也称灵敏率、真正例识别率）"><a href="#召回率-Recall（也称灵敏率、真正例识别率）" class="headerlink" title="召回率-Recall（也称灵敏率、真正例识别率）"></a>召回率-Recall（也称灵敏率、真正例识别率）</h3><p>Recall = TP/(TP + FN)<br>召回率的含义是指：正确识别的正例个数在实际为正例的样本数中的占比</p><h3 id="精确率：预测为真的正样本占所有预测为正样本的比例。"><a href="#精确率：预测为真的正样本占所有预测为正样本的比例。" class="headerlink" title="精确率：预测为真的正样本占所有预测为正样本的比例。"></a>精确率：预测为真的正样本占所有预测为正样本的比例。</h3><p>Precision = TP/(TP + FP)</p><h3 id="F1-Score（F度量或者F分数）"><a href="#F1-Score（F度量或者F分数）" class="headerlink" title="F1-Score（F度量或者F分数）"></a>F1-Score（F度量或者F分数）</h3><p>F度量 = 2Precision*Recall/(Precision + Recall)<br>F度量是是基于以上度量（精确率和召回率）衍生的计算指标，F1-Score的取值范围从0到1的，1代表模型的输出最好，0代表模型的输出结果最差。</p><h3 id="Loss-Function-损失函数"><a href="#Loss-Function-损失函数" class="headerlink" title="Loss Function(损失函数)"></a>Loss Function(损失函数)</h3><h2 id="图形评价-1"><a href="#图形评价-1" class="headerlink" title="图形评价"></a>图形评价</h2><h3 id="PR-Precision-Recall-曲线"><a href="#PR-Precision-Recall-曲线" class="headerlink" title="PR(Precision Recall) 曲线"></a>PR(Precision Recall) 曲线</h3><p>由于Precision与Recall之间的制衡关系, 可以利用PR曲线来寻找那个完美制衡点.也就是越靠右上越好.</p><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/1611742935175.jpg" alt="PR曲线.jpg"></p><p>举例: 在判断肿瘤是否为良性的诊断中, 我们可能会选择Recall高的模型, 即使会牺牲掉Precision. 宁愿100个里面判断20个为恶性(其中只有10个是正确的), 也不要判断为恶性有7个, 漏了两个.<br>所以面临如何选择的时候, 我们引入ROC曲线.</p><h3 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h3><p>横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。ROC的全名叫做Receiver Operating Characteristic，主要通过平面坐标系上的曲线来衡量分类模型结果好坏——ROC curve</p><p>纵坐标TPR是<strong>真正率</strong>，即是上述的指标召回率，TPR = TP/(TP + FN)<br>横坐标FPR是<strong>假正率</strong>，指代负样本中的错判率，FPR = FP/(FP + TN)</p><p>典型的ROC曲线是一个位于坐标点（0,0）和（1,1)对角线上方的曲线，因为对角线代表着随机分类器的分类效果。</p><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/ROC.jpg" alt="ROC曲线.jpg"></p><p>ROC曲线和P-R曲线有些类似，ROC曲线越靠近左上角性能越好。左上角坐标为(0, 1)，即FPR=0，TPR=1，根据FPR和TPR公可以得知，此时FN=0， FP=0，模型对所有样本分类正确，绘制ROC曲线很简单，首先对所有样本按预测概率排序，以每条样本的预测概率为阈值，计算相应的FPR和TPR，然后线段连接。</p><p>当数据量少时，绘制的ROC曲线不平滑；当数据量大时，绘制的ROC曲线会趋于平滑。理想中的ROC缺陷应该是平滑的, 因为通过提高敏感度, 错误率也应该是随之上升. 如果不够平滑, 有可能是发生了overfitting或者是样本不足.</p><h3 id="AUC指标"><a href="#AUC指标" class="headerlink" title="AUC指标"></a>AUC指标</h3><p>当然我们的想法是TPrate越高越好,FPrate越低越好. 显然是不可能的, 因此在ROC的基础上又引入了AUC. 它用来表示ROC曲线下的三角形面积大小，通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的performance。</p><h1 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h1><h2 id="多分类转化为2vs2问题来评价"><a href="#多分类转化为2vs2问题来评价" class="headerlink" title="多分类转化为2vs2问题来评价"></a>多分类转化为2vs2问题来评价</h2><p>对于多分类问题，或者在二分类问题中，我们有时候会有多组混淆矩阵。<br>例如：多次训练或者在多个数据集上训练的结果，那么估算全局性能的方法有两种，分为宏平均（macro-average）和微平均（micro-average）。简单理解，宏平均就是先算出每个混淆矩阵的P值和R值，然后取得平均P值macro-P和平均R值macro-R，再算出[Math Processing Error]或[Math Processing Error]，而微平均则是计算出混淆矩阵的平均TP、FP、TN、FN，接着进行计算P、R，进而求出[Math Processing Error]或[Math Processing Error]。其它分类指标同理，均可以通过宏平均/微平均计算得出。</p><p>准确率：与二分类相同，预测正确的样本占总样本的比例。<br>精确率： ‘macro’， 对于每个标签，分别计算Precision，然后取不加权平均<br>查全率： ‘macro’，对于每个标签，分别计算Recall，然后取不加权平均<br>F1-Score：‘macro’， 对于每个标签，分别计算发，然后取不加权平均<br>‘micro’, 将n个二分类评价的TP,FP,FN对应相加，计算P和R，然后求得F1<br>一般macro-f1和micro-f1都高的分类器性能好</p><p>需要注意的是，在多分类任务场景中，如果非要用一个综合考量的metric的话，宏平均会比微平均更好一些，因为宏平均受稀有类别影响更大。宏平均平等对待每一个类别，所以它的值主要受到稀有类别的影响，而微平均平等考虑数据集中的每一个样本，所以它的值受到常见类别的影响比较大。</p><h2 id="多分类评价指标"><a href="#多分类评价指标" class="headerlink" title="多分类评价指标"></a>多分类评价指标</h2><h3 id="Kappa系数"><a href="#Kappa系数" class="headerlink" title="Kappa系数"></a>Kappa系数</h3><p>kappa系数是用在统计学中评估一致性的一种方法，取值范围是[-1,1]，实际应用中，一般是[0,1]，与ROC曲线中一般不会出现下凸形曲线的原理类似。这个系数的值越高，则代表模型实现的分类准确度越高。<br>K = (P0-Pe) / (1-Pe)</p><p>P0表示总体分类精度<br>Pe表示SUM（第i类真实样本数*第i类预测出来的样本数）/样本总数平方</p><h3 id="海明距离"><a href="#海明距离" class="headerlink" title="海明距离"></a>海明距离</h3><h3 id="杰卡德相似系数"><a href="#杰卡德相似系数" class="headerlink" title="杰卡德相似系数"></a>杰卡德相似系数</h3><h3 id="铰链损失"><a href="#铰链损失" class="headerlink" title="铰链损失"></a>铰链损失</h3>]]></content>
      
      
      <categories>
          
          <category> 方法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyEcharts常用可视化组件-函数化</title>
      <link href="2021/01/15/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9APyEcharts%E5%B8%B8%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%84%E4%BB%B6-%E5%87%BD%E6%95%B0%E5%8C%96/"/>
      <url>2021/01/15/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9APyEcharts%E5%B8%B8%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%84%E4%BB%B6-%E5%87%BD%E6%95%B0%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是自己所做项目中实现的画图功能代码块，如有错误之处请指正。</em></strong></p><h3 id="折线堆叠"><a href="#折线堆叠" class="headerlink" title="折线堆叠"></a>折线堆叠</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mutiple_Lines = (</span><br><span class="line">    Line(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))</span><br><span class="line">    .add_xaxis(x_deal)</span><br><span class="line">    .add_yaxis(y_name_1, y_value_1)</span><br><span class="line">    .add_yaxis(y_name_2, y_value_2)</span><br><span class="line">    .add_yaxis(y_name_3, y_value_3)</span><br><span class="line">    .add_yaxis(y_name_4, y_value_4)</span><br><span class="line">    <span class="comment"># 继续添加堆叠折线数据</span></span><br><span class="line">    .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">"各区二手房成交量"</span>, subtitle=<span class="string">"数据截止10月底"</span>))</span><br><span class="line">    .set_series_opts(</span><br><span class="line">    label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>)</span><br><span class="line">    ,markpoint_opts=opts.MarkPointOpts(data=[opts.MarkPointItem(type_=<span class="string">"max"</span>, name=<span class="string">"最大值"</span>)])</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h3 id="柱状图堆叠"><a href="#柱状图堆叠" class="headerlink" title="柱状图堆叠"></a>柱状图堆叠</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Bar_axis</span>(<span class="params">x, y1_name, y1_values, y2_name, y2_values, y3_name, y3_values,title</span>):</span></span><br><span class="line">    bar = (</span><br><span class="line">        Bar(init_opts=opts.InitOpts(width=<span class="string">"900px"</span>, height=<span class="string">"600px"</span>, theme=ThemeType.LIGHT))</span><br><span class="line">            .add_xaxis(x)</span><br><span class="line">            .add_yaxis(y1_name, y1_values)</span><br><span class="line">            .add_yaxis(y2_name, y2_values)</span><br><span class="line">            .add_yaxis(y3_name, y3_values)</span><br><span class="line">            .set_series_opts(</span><br><span class="line">            label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">            )</span><br><span class="line">            .set_global_opts(</span><br><span class="line">            title_opts=opts.TitleOpts(title=title),</span><br><span class="line">            <span class="comment"># xaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=-45), is_inverse=True)</span></span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="柱状图和折线图双Y轴-grid网格多图，index传参"><a href="#柱状图和折线图双Y轴-grid网格多图，index传参" class="headerlink" title="柱状图和折线图双Y轴,grid网格多图，index传参"></a>柱状图和折线图双Y轴,grid网格多图，index传参</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar1_line1_with_two_axis</span>(<span class="params">x, y_bar, y_line, y_bar_name, y_line_name, sub_title, index, title_left, titel_top</span>):</span></span><br><span class="line">    bar = (</span><br><span class="line">        Bar(init_opts=opts.InitOpts(width=<span class="string">'600px'</span>, height=<span class="string">'300px'</span>))</span><br><span class="line">            .add_xaxis(x)</span><br><span class="line">            .add_yaxis(</span><br><span class="line">                y_bar_name,</span><br><span class="line">                y_bar,</span><br><span class="line">                xaxis_index=index,  <span class="comment"># 需要变动的，图层中第几条X轴</span></span><br><span class="line">                yaxis_index=index * <span class="number">2</span>,  <span class="comment"># 需要变动的，，图层中第几条Y轴</span></span><br><span class="line">                color=<span class="string">"#5793f3"</span>,</span><br><span class="line">            )</span><br><span class="line">            .set_global_opts(</span><br><span class="line">            yaxis_opts=opts.AxisOpts(</span><br><span class="line">                name=y_bar_name,</span><br><span class="line">                min_=<span class="number">0</span>,</span><br><span class="line">                max_=<span class="number">25000</span>,</span><br><span class="line">                position=<span class="string">"right"</span>,</span><br><span class="line">                grid_index=index,  <span class="comment"># 需要变动的 y轴</span></span><br><span class="line">                axisline_opts=opts.AxisLineOpts(linestyle_opts=opts.LineStyleOpts(color=<span class="string">"#5793f3"</span>)),</span><br><span class="line">                axislabel_opts=opts.LabelOpts(formatter=<span class="string">"{value}"</span>),</span><br><span class="line">            ),</span><br><span class="line">            title_opts=opts.TitleOpts(title=sub_title, pos_left=title_left, pos_top=titel_top),</span><br><span class="line">            tooltip_opts=opts.TooltipOpts(trigger=<span class="string">"axis"</span>, axis_pointer_type=<span class="string">"cross"</span>),</span><br><span class="line">            legend_opts=opts.LegendOpts(pos_left=<span class="string">"40%"</span>, pos_bottom=<span class="string">"0%"</span>),  <span class="comment"># 图例的位置</span></span><br><span class="line">        )</span><br><span class="line">            .extend_axis(</span><br><span class="line">            yaxis=opts.AxisOpts(</span><br><span class="line">                type_=<span class="string">"value"</span>,</span><br><span class="line">                name=y_line_name,</span><br><span class="line">                min_=<span class="number">0</span>,</span><br><span class="line">                max_=<span class="number">3</span>,</span><br><span class="line">                position=<span class="string">"left"</span>,</span><br><span class="line">                axisline_opts=opts.AxisLineOpts(linestyle_opts=opts.LineStyleOpts(color=<span class="string">"#675bba"</span>)),</span><br><span class="line">                axislabel_opts=opts.LabelOpts(formatter=<span class="string">"{value}"</span>),</span><br><span class="line">                splitline_opts=opts.SplitLineOpts(</span><br><span class="line">                    is_show=<span class="literal">True</span>,</span><br><span class="line">                    linestyle_opts=opts.LineStyleOpts(opacity=<span class="number">1</span>)),</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    line = (</span><br><span class="line">        Line()</span><br><span class="line">            .add_xaxis(x)</span><br><span class="line">            .add_yaxis(</span><br><span class="line">                y_line_name,</span><br><span class="line">                y_line,</span><br><span class="line">                xaxis_index=index,  <span class="comment"># 需要变动的，图层中第几条X轴</span></span><br><span class="line">                yaxis_index=index * <span class="number">2</span> + <span class="number">1</span>,  <span class="comment"># 需要变动的，图层中第几条Y轴</span></span><br><span class="line">                color=<span class="string">"#675bba"</span>,</span><br><span class="line">                label_opts=opts.LabelOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">                z_level=<span class="number">1</span>  <span class="comment"># z_level将折线图置于直方图之上，控制图表的显示层级,不然会被直方图遮挡</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    overlap = bar.overlap(line)</span><br><span class="line">    <span class="keyword">return</span> overlap</span><br></pre></td></tr></tbody></table></figure><h3 id="单一柱状图"><a href="#单一柱状图" class="headerlink" title="单一柱状图"></a>单一柱状图</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar_single</span>(<span class="params">x, y_name, y_bar_value, title, subtitle</span>):</span></span><br><span class="line">    bar = (</span><br><span class="line">        Bar(init_opts=opts.InitOpts(width=<span class="string">'800px'</span>, height=<span class="string">'400px'</span>))</span><br><span class="line">            .add_xaxis(x)</span><br><span class="line">            .add_yaxis(y_name, y_bar_value, color=<span class="string">"#5793f3"</span>)</span><br><span class="line">            .set_global_opts(</span><br><span class="line">            title_opts=opts.TitleOpts(title=title, subtitle=subtitle),</span><br><span class="line">            axispointer_opts=opts.AxisPointerOpts(is_show=<span class="literal">True</span>, type_=<span class="string">"shadow"</span>),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> bar</span><br></pre></td></tr></tbody></table></figure><h3 id="柱状图，双Y轴"><a href="#柱状图，双Y轴" class="headerlink" title="柱状图，双Y轴"></a>柱状图，双Y轴</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bars_with_two_axis</span>(<span class="params">x, y1_name, y1_values, y2_name, y2_values, title</span>):</span></span><br><span class="line">    bar = (</span><br><span class="line">        Bar(init_opts=opts.InitOpts(width=<span class="string">"1200px"</span>, height=<span class="string">"600px"</span>))</span><br><span class="line">            .add_xaxis(xaxis_data=x)</span><br><span class="line">            .add_yaxis(series_name=y1_name, y_axis=y1_values, yaxis_index=<span class="number">0</span>, color=COLORS[<span class="number">1</span>])</span><br><span class="line">            .add_yaxis(series_name=y2_name, y_axis=y2_values, yaxis_index=<span class="number">1</span>, color=COLORS[<span class="number">0</span>])</span><br><span class="line">            .extend_axis(</span><br><span class="line">            yaxis=opts.AxisOpts(</span><br><span class="line">                name=y2_name,</span><br><span class="line">                type_=<span class="string">"value"</span>,</span><br><span class="line">                <span class="comment"># min_=0,</span></span><br><span class="line">                <span class="comment"># max_=250,</span></span><br><span class="line">                position=<span class="string">"right"</span>,</span><br><span class="line">                axisline_opts=opts.AxisLineOpts(</span><br><span class="line">                    linestyle_opts=opts.LineStyleOpts(color=COLORS[<span class="number">1</span>])</span><br><span class="line">                ),</span><br><span class="line">                axislabel_opts=opts.LabelOpts(formatter=<span class="string">"{value}"</span>),</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">            .set_global_opts(</span><br><span class="line">            yaxis_opts=opts.AxisOpts(</span><br><span class="line">                type_=<span class="string">"value"</span>,</span><br><span class="line">                name=y1_name,</span><br><span class="line">                <span class="comment"># min_=0,</span></span><br><span class="line">                <span class="comment"># max_=250,</span></span><br><span class="line">                position=<span class="string">"left"</span>,</span><br><span class="line">                offset=<span class="number">0</span>,</span><br><span class="line">                axisline_opts=opts.AxisLineOpts(</span><br><span class="line">                    linestyle_opts=opts.LineStyleOpts(color=COLORS[<span class="number">0</span>])</span><br><span class="line">                ),</span><br><span class="line">                axislabel_opts=opts.LabelOpts(formatter=<span class="string">"{value}"</span>),</span><br><span class="line">            ),</span><br><span class="line">            tooltip_opts=opts.TooltipOpts(trigger=<span class="string">"axis"</span>, axis_pointer_type=<span class="string">"cross"</span>),</span><br><span class="line">            title_opts=opts.TitleOpts(title=title),</span><br><span class="line">            xaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=-<span class="number">45</span>), is_inverse=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="柱状-2条折线，双轴"><a href="#柱状-2条折线，双轴" class="headerlink" title="柱状+2条折线，双轴"></a>柱状+2条折线，双轴</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 柱状图+两条折线，双y轴</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar1_mix_line2</span>(<span class="params">x, y_bar_name, y_line1_name,y_line2_name, y_bar_value, y_line1_value, y_line2_value,title,subtitle</span>):</span></span><br><span class="line">    bar = (</span><br><span class="line">        Bar(init_opts=opts.InitOpts(width=<span class="string">"800px"</span>, height=<span class="string">"400px"</span>,theme=ThemeType.LIGHT))</span><br><span class="line">            .add_xaxis(xaxis_data=x)</span><br><span class="line">            .add_yaxis(</span><br><span class="line">                series_name=y_bar_name,</span><br><span class="line">                y_axis=y_bar_value,</span><br><span class="line">                label_opts=opts.LabelOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">            )</span><br><span class="line">            .extend_axis(</span><br><span class="line">                yaxis=opts.AxisOpts(</span><br><span class="line">                    name=<span class="string">'百分比'</span>,</span><br><span class="line">                    type_=<span class="string">"value"</span>,</span><br><span class="line">                    min_=<span class="number">0</span>,</span><br><span class="line">                    max_=<span class="number">0.5</span>,</span><br><span class="line">                    interval=<span class="number">0.1</span>,</span><br><span class="line">                    axislabel_opts=opts.LabelOpts(formatter=<span class="string">"{value}"</span>),</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">            .set_global_opts(</span><br><span class="line">            tooltip_opts=opts.TooltipOpts(</span><br><span class="line">                is_show=<span class="literal">True</span>, trigger=<span class="string">"axis"</span>, axis_pointer_type=<span class="string">"cross"</span></span><br><span class="line">            ),</span><br><span class="line">            xaxis_opts=opts.AxisOpts(</span><br><span class="line">                type_=<span class="string">"category"</span>,</span><br><span class="line">                axispointer_opts=opts.AxisPointerOpts(is_show=<span class="literal">True</span>, type_=<span class="string">"shadow"</span>),</span><br><span class="line">            ),</span><br><span class="line">            yaxis_opts=opts.AxisOpts(</span><br><span class="line">                name=y_bar_name,</span><br><span class="line">                type_=<span class="string">"value"</span>,</span><br><span class="line">                min_=<span class="number">0</span>,</span><br><span class="line">                max_=<span class="number">15</span>,</span><br><span class="line">                interval=<span class="number">3</span>,</span><br><span class="line">                axislabel_opts=opts.LabelOpts(formatter=<span class="string">"{value}"</span>),</span><br><span class="line">                axistick_opts=opts.AxisTickOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">                splitline_opts=opts.SplitLineOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">            ),</span><br><span class="line">            title_opts=opts.TitleOpts(title=title, subtitle=subtitle),</span><br><span class="line">            legend_opts=opts.LegendOpts(pos_right=<span class="string">"20%"</span>),  <span class="comment"># 图例的位置</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    line = (</span><br><span class="line">        Line()</span><br><span class="line">            .add_xaxis(xaxis_data=x)</span><br><span class="line">            .add_yaxis(</span><br><span class="line">            series_name=y_line1_name,</span><br><span class="line">            yaxis_index=<span class="number">1</span>,</span><br><span class="line">            y_axis=y_line1_value,</span><br><span class="line">            label_opts=opts.LabelOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">            z_level=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">            .add_yaxis(</span><br><span class="line">            series_name=y_line2_name,</span><br><span class="line">            yaxis_index=<span class="number">1</span>,</span><br><span class="line">            y_axis=y_line2_value,</span><br><span class="line">            label_opts=opts.LabelOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">            z_level=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    bar.overlap(line)</span><br><span class="line">    <span class="keyword">return</span> bar</span><br></pre></td></tr></tbody></table></figure><h3 id="表格组件"><a href="#表格组件" class="headerlink" title="表格组件"></a>表格组件</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># header_list，row_list 都是list格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Table_bas</span>(<span class="params">header_list,row_list,title</span>):</span></span><br><span class="line">    table = Table()</span><br><span class="line">    table.add(header_list, row_list)</span><br><span class="line">    table.set_global_opts(</span><br><span class="line">        title_opts=ComponentTitleOpts(title=title)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> table</span><br></pre></td></tr></tbody></table></figure><h3 id="中国地图"><a href="#中国地图" class="headerlink" title="中国地图"></a>中国地图</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># is_ignore_nonexistent_coord=True只会显示原库中有的地理坐标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Geo_base</span>(<span class="params">provs_list,values_list,title</span>):</span></span><br><span class="line">    geo = (</span><br><span class="line">        Geo(is_ignore_nonexistent_coord=<span class="literal">True</span>)</span><br><span class="line">            .add_schema(maptype=<span class="string">"china"</span>)</span><br><span class="line">            .add(<span class="literal">None</span>, [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>(provs_list,values_list)])</span><br><span class="line">            .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>),)</span><br><span class="line">            .set_global_opts(</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(range_color=[<span class="string">'#CCEBFF'</span>, <span class="string">'#22DDDD'</span>, <span class="string">'#0099FF'</span>, <span class="string">'#003D66'</span>],)</span><br><span class="line">            , title_opts=opts.TitleOpts(title=title)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> geo</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="柱状图，翻转XY轴"><a href="#柱状图，翻转XY轴" class="headerlink" title="柱状图，翻转XY轴"></a>柱状图，翻转XY轴</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 柱状系列图，单Y轴，翻转XY轴</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Bar_reversal_axis</span>(<span class="params">x, y1_name, y1_values, y2_name, y2_values, y3_name, y3_values,title</span>):</span></span><br><span class="line">    bar = (</span><br><span class="line">        Bar(init_opts=opts.InitOpts(width=<span class="string">"900px"</span>, height=<span class="string">"600px"</span>, theme=ThemeType.LIGHT))</span><br><span class="line">            .add_xaxis(x)</span><br><span class="line">            .add_yaxis(y1_name, y1_values)</span><br><span class="line">            .add_yaxis(y2_name, y2_values)</span><br><span class="line">            .add_yaxis(y3_name, y3_values)</span><br><span class="line">            .reversal_axis()</span><br><span class="line">            .set_series_opts(</span><br><span class="line">            label_opts=opts.LabelOpts(position=<span class="string">"right"</span>,is_show=<span class="literal">False</span>),</span><br><span class="line">            markpoint_opts=opts.MarkPointOpts(</span><br><span class="line">            data=[</span><br><span class="line">                opts.MarkPointItem(type_=<span class="string">"max"</span>, name=<span class="string">"最大值"</span>),</span><br><span class="line">                opts.MarkPointItem(type_=<span class="string">"min"</span>, name=<span class="string">"最小值"</span>),</span><br><span class="line">                opts.MarkPointItem(type_=<span class="string">"average"</span>, name=<span class="string">"平均值"</span>),</span><br><span class="line">            ]),</span><br><span class="line">            )</span><br><span class="line">            .set_global_opts(title_opts=opts.TitleOpts(title=title))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> bar</span><br></pre></td></tr></tbody></table></figure><h3 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Heatmap_with_label_show</span>(<span class="params">x_value,values,title</span>):</span></span><br><span class="line"></span><br><span class="line">    heatmap = (</span><br><span class="line">        HeatMap(init_opts=opts.InitOpts(width=<span class="string">"900px"</span>, height=<span class="string">"600px"</span>, ))</span><br><span class="line">            .add_xaxis(x_value)</span><br><span class="line">            .add_yaxis(</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">            x_value,</span><br><span class="line">            values,</span><br><span class="line">            label_opts=opts.LabelOpts(is_show=<span class="literal">True</span>, position=<span class="string">"inside"</span>),</span><br><span class="line">        )</span><br><span class="line">            .set_global_opts(</span><br><span class="line">            title_opts=opts.TitleOpts(title=title),</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(</span><br><span class="line">                min_=<span class="number">0</span>,</span><br><span class="line">                max_=<span class="number">1</span>,</span><br><span class="line">                range_color=[<span class="string">'#CCEBFF'</span>, <span class="string">'#22DDDD'</span>, <span class="string">'#0099FF'</span>, <span class="string">'#003D66'</span>],  <span class="comment"># 设置主题颜色</span></span><br><span class="line"></span><br><span class="line">            ),</span><br><span class="line">            xaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=-<span class="number">45</span>), is_inverse=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> heatmap</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 方法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyEcharts </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas数据清洗步骤总结</title>
      <link href="2021/01/12/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9APandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93/"/>
      <url>2021/01/12/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9APandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是自己在完成项目后总结的经验，如有错误之处请指正。</em></strong></p><h1 id="一-读原文件数据"><a href="#一-读原文件数据" class="headerlink" title="一.读原文件数据"></a>一.读原文件数据</h1><h2 id="1-整体读数据，再生成dataframe，速度快"><a href="#1-整体读数据，再生成dataframe，速度快" class="headerlink" title="1.整体读数据，再生成dataframe，速度快"></a>1.整体读数据，再生成dataframe，速度快</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果数据是字典型列表，列表型列表均可以使用此方法</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    str_lines = <span class="built_in">str</span>(lines).replace(<span class="string">"'"</span>, <span class="string">""</span>).replace(<span class="string">r"\n"</span>, <span class="string">""</span>)  <span class="comment"># 转为字符串，同时删除冗余字符</span></span><br><span class="line">    list_dict = <span class="built_in">eval</span>(str_lines)   <span class="comment"># 从字符串转回包含字典的列表</span></span><br><span class="line">    df = pd.DataFrame(list_dict)</span><br></pre></td></tr></tbody></table></figure><h2 id="2-按行读取，动态分配内存，速度慢"><a href="#2-按行读取，动态分配内存，速度慢" class="headerlink" title="2.按行读取，动态分配内存，速度慢"></a>2.按行读取，动态分配内存，速度慢</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此方法需要自行设置dataframe列名</span></span><br><span class="line">my_dict = {}</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        my_dict = <span class="built_in">eval</span>(line)</span><br><span class="line">        df = df.append(my_dict, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="3-创建dataframe"><a href="#3-创建dataframe" class="headerlink" title="3.创建dataframe"></a>3.创建dataframe</h2><h3 id="创建空dataframe（仅列名）"><a href="#创建空dataframe（仅列名）" class="headerlink" title="创建空dataframe（仅列名）"></a>创建空dataframe（仅列名）</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df = pd.DataFrame(columns=[<span class="string">'id'</span>, <span class="string">'domain'</span>, <span class="string">'tenant_id'</span>])</span><br></pre></td></tr></tbody></table></figure><h3 id="将字典列表转换成dataframe"><a href="#将字典列表转换成dataframe" class="headerlink" title="将字典列表转换成dataframe"></a>将字典列表转换成dataframe</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">list_dict = [{<span class="string">'id'</span>:<span class="number">1234</span>,<span class="string">'domain'</span>:<span class="string">'STR'</span>,<span class="string">'tenant_id'</span>:<span class="string">'CN'</span>},{<span class="string">'id'</span>:<span class="number">14526</span>,<span class="string">'domain'</span>:<span class="string">'EDD'</span>,<span class="string">'tenant_id'</span>:<span class="string">'SG'</span>},....]</span><br><span class="line">my_df = pd.DataFrame(list_dict)</span><br></pre></td></tr></tbody></table></figure><h3 id="从dataframe中选取一列，创建Series"><a href="#从dataframe中选取一列，创建Series" class="headerlink" title="从dataframe中选取一列，创建Series"></a>从dataframe中选取一列，创建Series</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_se = pd.Series(my_df[<span class="string">'topic_id'</span>].values, index=my_df[<span class="string">'group'</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="4-解决df中汉字编码问题"><a href="#4-解决df中汉字编码问题" class="headerlink" title="4.解决df中汉字编码问题"></a>4.解决df中汉字编码问题</h2><p>如果汉字中遭遇编码问题，可以遍历修改df中编码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> my_df.columns:</span><br><span class="line">    <span class="keyword">if</span> my_df[col].dtype == <span class="built_in">object</span>:</span><br><span class="line">        my_df[col] = my_df[col].apply(</span><br><span class="line">            <span class="keyword">lambda</span> x: np.nan <span class="keyword">if</span> x == np.nan <span class="keyword">else</span> <span class="built_in">str</span>(x).encode(<span class="string">'utf-8'</span>, <span class="string">'replace'</span>).decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="二-df数据预处理"><a href="#二-df数据预处理" class="headerlink" title="二.df数据预处理"></a>二.df数据预处理</h1><h2 id="1-去重"><a href="#1-去重" class="headerlink" title="1.去重"></a>1.去重</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按列['topic_id']去重</span></span><br><span class="line">my_df1 = pd.read_csv(<span class="string">"my_df"</span>).drop_duplicates(subset=[<span class="string">'topic_id'</span>])</span><br><span class="line"><span class="comment"># 按列['topic_id', 'reply_id', 'reply_pub_time'] 去重</span></span><br><span class="line">my_df2 = pd.read_csv(<span class="string">"my_df"</span>).drop_duplicates(subset=[<span class="string">'col1'</span>, <span class="string">'col2'</span>, <span class="string">'col3'</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="2-空值处理"><a href="#2-空值处理" class="headerlink" title="2.空值处理"></a>2.空值处理</h2><h3 id="空值补0"><a href="#空值补0" class="headerlink" title="空值补0"></a>空值补0</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df1 = my_df.fillna(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="删除空值行"><a href="#删除空值行" class="headerlink" title="删除空值行"></a>删除空值行</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axis：0: 行操作（默认），1: 列操作</span></span><br><span class="line"><span class="comment"># how：any: 只要有空值就删除（默认），all:全部为空值才删除</span></span><br><span class="line">my_df1 = my_df.dropna(axis=<span class="number">0</span>, how=<span class="string">'any'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="3-修改列数据格式"><a href="#3-修改列数据格式" class="headerlink" title="3.修改列数据格式"></a>3.修改列数据格式</h2><h3 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'dt'</span>] = pd.to_datetime(my_df[<span class="string">'dt'</span>], <span class="built_in">format</span>=<span class="string">'%Y/%m/%d'</span>)</span><br><span class="line"><span class="comment"># 也可以多列同时修改</span></span><br><span class="line">my_df[[<span class="string">'col1'</span>, <span class="string">'col2'</span>, <span class="string">'col3'</span>]] = pd.to_datetime(my_df[[<span class="string">'col1'</span>, <span class="string">'col2'</span>, <span class="string">'col3'</span>]], <span class="built_in">format</span>=<span class="string">'%Y/%m/%d'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="去掉默认格式中的多余部分（如汉字、英文）"><a href="#去掉默认格式中的多余部分（如汉字、英文）" class="headerlink" title="去掉默认格式中的多余部分（如汉字、英文）"></a>去掉默认格式中的多余部分（如汉字、英文）</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始数据中含[]</span></span><br><span class="line"><span class="comment"># strip() ,去掉()中内容</span></span><br><span class="line">my_df[<span class="string">'area'</span>] = my_df[<span class="string">'area'</span>].<span class="built_in">str</span>[<span class="number">0</span>].<span class="built_in">str</span>.strip(<span class="string">'㎡'</span>).astype(<span class="built_in">float</span>)  </span><br><span class="line">my_df[<span class="string">'class'</span>] = my_df[<span class="string">'class'</span>].<span class="built_in">str</span>[<span class="number">0</span>].<span class="built_in">str</span>.strip(<span class="string">'室'</span>).astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># replace()，将()内容进行替换</span></span><br><span class="line">my_df[<span class="string">'follower'</span>] = my_df[<span class="string">'follower'</span>].<span class="built_in">str</span>.strip(<span class="string">'关注（人）'</span>).astype(<span class="built_in">float</span>)</span><br><span class="line">my_df[<span class="string">'views'</span>] = my_df[<span class="string">'views'</span>].<span class="built_in">str</span>.strip(<span class="string">'浏览（次）'</span>).replace(<span class="string">'暂无数据'</span>, <span class="string">''</span>)  </span><br></pre></td></tr></tbody></table></figure><h3 id="修改有编码问题的数据"><a href="#修改有编码问题的数据" class="headerlink" title="修改有编码问题的数据"></a>修改有编码问题的数据</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'col'</span>] = my_df[<span class="string">'col'</span>].apply(<span class="keyword">lambda</span> x: np.nan <span class="keyword">if</span> x == np.nan <span class="keyword">else</span> <span class="built_in">str</span>(x).encode(<span class="string">'utf-8'</span>).decode(<span class="string">'unicode_escape'</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="4-列类型转换"><a href="#4-列类型转换" class="headerlink" title="4.列类型转换"></a>4.列类型转换</h2><h3 id="转为数据类型"><a href="#转为数据类型" class="headerlink" title="转为数据类型"></a>转为数据类型</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'area'</span>] = my_df[<span class="string">'area'</span>].astype(<span class="built_in">float</span>)  </span><br><span class="line"><span class="comment"># 可以多列一起转换</span></span><br><span class="line">my_df[[<span class="string">'books'</span>,<span class="string">'group_num'</span>,<span class="string">'music'</span>]] = my_df[[<span class="string">'books'</span>,<span class="string">'group_num'</span>,<span class="string">'music'</span>]].apply(pd.to_numeric)</span><br><span class="line">my_df[<span class="string">'views'</span>] = my_df[<span class="string">'views'</span>].<span class="built_in">str</span>.strip(<span class="string">'浏览（次）'</span>).apply(pd.to_numeric, errors=<span class="string">'coerce'</span>)</span><br><span class="line">my_df[<span class="string">'transmit'</span>] = my_df[<span class="string">'transmit'</span>].<span class="built_in">str</span>.strip(<span class="string">'['</span>).<span class="built_in">str</span>.strip(<span class="string">']'</span>).apply(pd.to_numeric)</span><br></pre></td></tr></tbody></table></figure><h2 id="5-数据裁剪"><a href="#5-数据裁剪" class="headerlink" title="5.数据裁剪"></a>5.数据裁剪</h2><h3 id="选择时间范围数据"><a href="#选择时间范围数据" class="headerlink" title="选择时间范围数据"></a>选择时间范围数据</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df1 = my_df[(my_df[<span class="string">'deal_dt'</span>] &lt; <span class="string">'2020-11-01'</span>) &amp; (my_df[<span class="string">'deal_dt'</span>] &gt; <span class="string">'2020-05-31'</span>)]</span><br></pre></td></tr></tbody></table></figure><h3 id="选择满足条件的行"><a href="#选择满足条件的行" class="headerlink" title="选择满足条件的行"></a>选择满足条件的行</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_df1 = my_df[(my_df[<span class="string">'type'</span>] != <span class="string">'车库'</span>) &amp; (my_df[<span class="string">'type'</span>] != <span class="string">'别墅'</span>)]</span><br><span class="line">my_df1 = my_df.loc[my_df[<span class="string">'group'</span>] == <span class="string">'blabla'</span>,[<span class="string">'col1'</span>]][<span class="string">'clo2'</span>].drop_duplicates()</span><br></pre></td></tr></tbody></table></figure><h3 id="删除满足条件的行"><a href="#删除满足条件的行" class="headerlink" title="删除满足条件的行"></a>删除满足条件的行</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df1 = my_df.drop(my_df[(my_df[<span class="string">'group'</span>] == <span class="string">'wakao'</span>) | (my_df[<span class="string">'group'</span>] == <span class="string">'670255'</span>)].index)</span><br></pre></td></tr></tbody></table></figure><h3 id="去除无限大无限小"><a href="#去除无限大无限小" class="headerlink" title="去除无限大无限小"></a>去除无限大无限小</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_dataset</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(df, pd.DataFrame), <span class="string">"df needs to be a pd.DataFrame"</span></span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)  <span class="comment"># df.dropna(axis=0 , inplace=True) #不存在的值，删除整行，默认为0</span></span><br><span class="line">    indices_to_keep = ~df.isin([np.nan, np.inf, -np.inf]).<span class="built_in">any</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> df[indices_to_keep].astype(np.float64)</span><br></pre></td></tr></tbody></table></figure><h2 id="6-在原始列基础上新生列"><a href="#6-在原始列基础上新生列" class="headerlink" title="6.在原始列基础上新生列"></a>6.在原始列基础上新生列</h2><h3 id="提取时间中天、月、年"><a href="#提取时间中天、月、年" class="headerlink" title="提取时间中天、月、年"></a>提取时间中天、月、年</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'deal_dt_ym'</span>] = my_df[<span class="string">'deal_dt'</span>].dt.strftime(<span class="string">'%Y%m'</span>)</span><br><span class="line">hours = my_df[<span class="string">'reply_pub_time'</span>].dt.hour.value_counts(sort=<span class="literal">False</span>)</span><br><span class="line">my_df[<span class="string">'topic_day'</span>] = my_df[<span class="string">'topic_pub_time'</span>].dt.day</span><br><span class="line">my_df[<span class="string">'deal_year'</span>] = my_df[<span class="string">'deal_dt'</span>].dt.year</span><br><span class="line">my_df[<span class="string">'deal_month'</span>] = my_df[<span class="string">'deal_dt'</span>].dt.month</span><br></pre></td></tr></tbody></table></figure><h3 id="两列数据做差"><a href="#两列数据做差" class="headerlink" title="两列数据做差"></a>两列数据做差</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'used_total_diff_price'</span>] = my_df[<span class="string">'used_price'</span>] - my_df[<span class="string">'total_price'</span>]</span><br><span class="line">my_df[<span class="string">'col3'</span>] = (my_df[<span class="string">'col1'</span>] / my_df[<span class="string">'col2'</span>]).<span class="built_in">round</span>(decimals=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 与固定数据做差</span></span><br><span class="line">my_df[<span class="string">'year_diff'</span>] = (datetime.datetime.now() - my_df[<span class="string">'build_time'</span>])/<span class="number">365.2425</span></span><br><span class="line"><span class="comment"># 与固定数的加减</span></span><br><span class="line">my_df[<span class="string">'col'</span>] = my_df[<span class="string">'col'</span>] / <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><h3 id="求每个分组里面的均值"><a href="#求每个分组里面的均值" class="headerlink" title="求每个分组里面的均值"></a>求每个分组里面的均值</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_ = my_df.groupby([<span class="string">'deal_dt_ym'</span>])[<span class="string">'build_diff'</span>].apply(<span class="keyword">lambda</span> g: g.mean(skipna=<span class="literal">True</span>)).dt.days.tolist()</span><br></pre></td></tr></tbody></table></figure><h3 id="原列满足条件打标生成新列（满五年，tag-1）"><a href="#原列满足条件打标生成新列（满五年，tag-1）" class="headerlink" title="原列满足条件打标生成新列（满五年，tag=1）"></a>原列满足条件打标生成新列（满五年，tag=1）</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用apply函数, years字段满足''关键词，则判断这一列赋值为1,否则为0</span></span><br><span class="line">my_df[<span class="string">'5years'</span>] = my_df[<span class="string">'years'</span>].apply(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> <span class="string">'满五年'</span> <span class="keyword">in</span> x <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">my_df[<span class="string">'2years'</span>] = my_df[<span class="string">'years'</span>].apply(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> <span class="string">'满两年'</span> <span class="keyword">in</span> x <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 也可以使用正则</span></span><br><span class="line">my_df[<span class="string">'des'</span>] = my_df[<span class="string">'location'</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> <span class="built_in">len</span>(pattern.findall(x)) == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df = my_df[[<span class="string">'group'</span>,<span class="string">'topic_owner'</span>]].rename(columns={<span class="string">'topic_owner'</span>: <span class="string">'reply_id_2'</span>})</span><br></pre></td></tr></tbody></table></figure><h3 id="映射生成新列"><a href="#映射生成新列" class="headerlink" title="映射生成新列"></a>映射生成新列</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'tenant_id'</span>] = my_df[<span class="string">'tenant_id'</span>].<span class="built_in">map</span>(tenant_id_mapping)</span><br></pre></td></tr></tbody></table></figure><h3 id="将数据分段"><a href="#将数据分段" class="headerlink" title="将数据分段"></a>将数据分段</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'tag'</span>] = pd.cut(my_df[<span class="string">'deal_dt'</span>],[my_df[<span class="string">'deal_dt'</span>].<span class="built_in">min</span>(),pd.to_datetime(<span class="string">'2020-09-14'</span>),my_df[<span class="string">'deal_dt'</span>].<span class="built_in">max</span>()],labels=[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="7-错误数据订正（人为修改数据）"><a href="#7-错误数据订正（人为修改数据）" class="headerlink" title="7.错误数据订正（人为修改数据）"></a>7.错误数据订正（人为修改数据）</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df.loc[my_df[<span class="string">'topic_id'</span>] == <span class="string">'202721237'</span>, <span class="string">'topic_pub_time'</span>] = <span class="string">'2020-11-28 11:01:14'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="重置索引"><a href="#重置索引" class="headerlink" title="重置索引"></a>重置索引</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df_new = my_df.reset_index()</span><br></pre></td></tr></tbody></table></figure><h1 id="三、目标数据提取"><a href="#三、目标数据提取" class="headerlink" title="三、目标数据提取"></a>三、目标数据提取</h1><h2 id="1-获取某几列数据（按顺序）"><a href="#1-获取某几列数据（按顺序）" class="headerlink" title="1.获取某几列数据（按顺序）"></a>1.获取某几列数据（按顺序）</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取某列分组后的数据，生成格式为列表</span></span><br><span class="line">x = my_df.groupby(<span class="string">'col'</span>)[<span class="string">'col'</span>].unique().<span class="built_in">str</span>[<span class="number">0</span>].tolist()</span><br><span class="line"><span class="comment"># 按col列（特定顺序）分组</span></span><br><span class="line">x1 = my_df.sort_values(<span class="string">'col'</span>, ascending=<span class="literal">False</span>).groupby(<span class="string">'col'</span>)[<span class="string">'col'</span>].unique().<span class="built_in">str</span>[<span class="number">0</span>].tolist()</span><br><span class="line"><span class="comment"># 取两位小数</span></span><br><span class="line">y = my_df.sort_values(<span class="string">'col'</span>, ascending=<span class="literal">False</span>).groupby(<span class="string">'col1'</span>)[<span class="string">'col2'</span>].mean().<span class="built_in">round</span>(decimals=<span class="number">2</span>).tolist()</span><br><span class="line"><span class="comment"># 按两列顺序</span></span><br><span class="line">my_df_new = my_df.sort_values([<span class="string">'group'</span>,<span class="string">'reply_zan'</span>], ascending=[<span class="number">0</span>,<span class="number">0</span>]).groupby([<span class="string">'group'</span>,<span class="string">'topic_id'</span>]).head(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 提取除了某几列剩余别的列</span></span><br><span class="line">X = my_df[my_df.columns.difference([ <span class="string">'tenant_id'</span>,<span class="string">'type'</span>,<span class="string">'zhuangxiu'</span>,<span class="string">'other'</span>])]</span><br></pre></td></tr></tbody></table></figure><h2 id="2-获取某分组下（武侯区）的再分组（每年）数据个数"><a href="#2-获取某分组下（武侯区）的再分组（每年）数据个数" class="headerlink" title="2.获取某分组下（武侯区）的再分组（每年）数据个数"></a>2.获取某分组下（武侯区）的再分组（每年）数据个数</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_df[my_df[<span class="string">'tenant_id'</span>] == <span class="string">'武侯'</span>].groupby([<span class="string">'deal_dt_ym'</span>]).count()[<span class="string">'id'</span>].tolist()</span><br><span class="line">my_df[my_df[<span class="string">'tenant_id'</span>] == <span class="string">'武侯'</span>].groupby(<span class="string">'deal_dt_ym'</span>)[<span class="string">'avg_price'</span>].mean().astype(<span class="built_in">int</span>).tolist()</span><br><span class="line"><span class="comment"># value_counts()统计该分组的每种类型个数</span></span><br><span class="line">my_df[my_df[<span class="string">'des'</span>] == <span class="number">1</span>].groupby([<span class="string">'location'</span>])[<span class="string">'location'</span>].value_counts().index.tolist()</span><br></pre></td></tr></tbody></table></figure><h2 id="3-取列的索引"><a href="#3-取列的索引" class="headerlink" title="3.取列的索引"></a>3.取列的索引</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df[<span class="string">'tenant_id'</span>] = my_df[<span class="string">'tenant_id'</span>].sort_values().index.to_series().tolist()</span><br></pre></td></tr></tbody></table></figure><h2 id="4-比较两列关系提取行，a-b-则输出"><a href="#4-比较两列关系提取行，a-b-则输出" class="headerlink" title="4.比较两列关系提取行，a=b,则输出"></a>4.比较两列关系提取行，a=b,则输出</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将'reply_day'不等于'topic_day的行输出</span></span><br><span class="line">my_df_new = my_df.loc[my_df[<span class="string">'reply_day'</span>] != my_df[<span class="string">'topic_day'</span>],]</span><br></pre></td></tr></tbody></table></figure><h1 id="四、关联表连接"><a href="#四、关联表连接" class="headerlink" title="四、关联表连接"></a>四、关联表连接</h1><h2 id="1-inner-join"><a href="#1-inner-join" class="headerlink" title="1.inner join"></a>1.inner join</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_df3 = my_df1.merge(my_df2, left_on=[<span class="string">'group'</span>, <span class="string">'topic_id'</span>],right_on=[<span class="string">'group'</span>, <span class="string">'topic_id'</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="2-union-all"><a href="#2-union-all" class="headerlink" title="2.union all"></a>2.union all</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列名一致时是直接添加在原数据后面，列名不一致时有待验证？（在右边添加）</span></span><br><span class="line">row_concat = pd.concat([my_df1, my_df2]).drop_duplicates()</span><br></pre></td></tr></tbody></table></figure><h1 id="五-其它"><a href="#五-其它" class="headerlink" title="五.其它"></a>五.其它</h1><h2 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h2><h3 id="遍历groupby分组"><a href="#遍历groupby分组" class="headerlink" title="遍历groupby分组"></a>遍历groupby分组</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_df_groupby = my_df.groupby([<span class="string">'group'</span>, <span class="string">'reply_id_2'</span>])</span><br><span class="line">my_list_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> my_df_groupby:</span><br><span class="line">    restore = <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">set</span>(group[<span class="string">'reply_day'</span>].values.tolist()) &gt;= <span class="built_in">set</span>([<span class="number">28</span>, <span class="number">29</span>]) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    my_list_dict[<span class="string">'group'</span>].append(name[<span class="number">0</span>])</span><br><span class="line">    my_list_dict[<span class="string">'reply_id_2'</span>].append(name[<span class="number">1</span>])</span><br><span class="line">    my_list_dict[<span class="string">'29号留存'</span>].append(restore)</span><br></pre></td></tr></tbody></table></figure><h2 id="常用固定功能"><a href="#常用固定功能" class="headerlink" title="常用固定功能"></a>常用固定功能</h2><h3 id="交换字典key和value"><a href="#交换字典key和value" class="headerlink" title="交换字典key和value"></a>交换字典key和value</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_group_map = {v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> group_mapping.items()}</span><br></pre></td></tr></tbody></table></figure><h3 id="将Series某列数据按特定索引排序"><a href="#将Series某列数据按特定索引排序" class="headerlink" title="将Series某列数据按特定索引排序"></a>将Series某列数据按特定索引排序</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为将两个指标画到同一坐标系，需要按日均发帖小组顺序输出</span></span><br><span class="line">my_df = pd.DataFrame(used_se)</span><br><span class="line">my_df = my_df.reset_index()</span><br><span class="line">my_df[<span class="string">'group'</span>] = my_df[<span class="string">'group'</span>].astype(<span class="string">'category'</span>)</span><br><span class="line">my_df[<span class="string">'group'</span>].cat.set_categories(order_list, inplace=<span class="literal">True</span>)</span><br><span class="line">my_df.sort_values(<span class="string">'group'</span>, ascending=<span class="literal">True</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">my_df.set_index([<span class="string">'group'</span>])</span><br><span class="line">my_se = pd.Series(my_df[<span class="string">'topic_id'</span>].values, index=my_df[<span class="string">'group'</span>])</span><br></pre></td></tr></tbody></table></figure><h3 id="可以追加元素append的dict"><a href="#可以追加元素append的dict" class="headerlink" title="可以追加元素append的dict"></a>可以追加元素append的dict</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_days_dict = defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="计算列表A和列表B的差集"><a href="#计算列表A和列表B的差集" class="headerlink" title="计算列表A和列表B的差集"></a>计算列表A和列表B的差集</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retA = [i <span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">if</span> i <span class="keyword">in</span> y]</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 方法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> 数据清洗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目实战】豆瓣小组社区流量数据分析</title>
      <link href="2021/01/06/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E7%A4%BE%E5%8C%BA%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>2021/01/06/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E7%A4%BE%E5%8C%BA%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目目标"><a href="#1-项目目标" class="headerlink" title="1.项目目标"></a>1.项目目标</h1><p>作为数据分析的系列实战练习项目，本次研究的主要目的为：</p><ol><li>熟悉Python编程，通过爬虫获取豆瓣热门小组多维度数据，利用Pandas、PyEcharts进行分析和可视化；</li><li>掌握数据分析思维和方法，完成豆瓣小组日活、留存、用户画像等运营数据分析；</li><li>完成分析报告。</li></ol><h1 id="2-业务理解"><a href="#2-业务理解" class="headerlink" title="2.业务理解"></a>2.业务理解</h1><h2 id="豆瓣小组介绍"><a href="#豆瓣小组介绍" class="headerlink" title="豆瓣小组介绍"></a>豆瓣小组介绍</h2><p>豆瓣是一个以书影音信息为主，论坛功能为辅的社交APP。豆瓣论坛功能主要集中在小组。豆瓣小组，已经成为当代年轻人（特别是追星饭圈爱好者）聚集和社交的重要阵地。<br>截止2020年12月22号，豆瓣27个大类下一共有714757个小组，涵盖时尚、宠物、求职、租房、理财、读书、情感、美食、旅行、运动、职场、娱乐、兴趣、影视、闲趣、校园、生活、摄影、同城、音乐、科技、游戏、打卡、艺术、人文、动漫、追剧等方面。</p><h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>本文旨在基于对热门小组发帖、回复等维度的数据分析，了解豆瓣小组用户的活跃情况，以及通过对top小组成员的分析，刻画小组用户画像。</p><h1 id="3-数据爬取"><a href="#3-数据爬取" class="headerlink" title="3.数据爬取"></a>3.数据爬取</h1><p>利用Python的Selenium库爬取豆瓣部分小组数据，由于豆瓣小组每日发帖量巨大（日均12万左右）且豆瓣具有严厉的反爬虫机制，故仅针对25个热门小组爬取了2020年11月28号和2020年11月29号两天（周六周日）的数据。此外，针对TOP小组活跃用户进行数据采集，刻画小组活跃用户画像。</p><p>需要说明的是:</p><blockquote><p>豆瓣小组全站范围每增加一个新帖，帖子的id就会加一，程序在12月4号到12月16(20?)号期间按照帖子id依次爬取11月28号和11月29号两天发布的帖子及回复。<br>由于当天不仅可以回复当日新发帖子也可以回复过往发布的帖子，29号以后也可以回复28号和29号发布的贴子，因此，所有活跃指标均基于当日（28、29号）新发帖子，故并不能完整反映小组活跃程度，小组真实活跃情况应远高于本文分析结果。<br>不仅如此，本文的部分分析指标（如点赞数等）也与程序执行的时间段高度相关。</p></blockquote><h3 id="热门小组选取："><a href="#热门小组选取：" class="headerlink" title="热门小组选取："></a>热门小组选取：</h3><table><thead><tr><th align="center">序号</th><th align="center">id</th><th align="center">小组名</th><th align="center">成立时间</th><th align="center">成员数</th><th align="center">小组标签</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">634189</td><td align="center">豆瓣吃瓜人才组</td><td align="center">2018-04-02</td><td align="center">553565</td><td align="center">娱乐、八卦、人才、豆瓣、吃瓜</td></tr><tr><td align="center">2</td><td align="center">babysheep</td><td align="center">青青草原</td><td align="center">2018-07-23</td><td align="center">464154</td><td align="center">娱乐、学习、生活、旅游、科技</td></tr><tr><td align="center">3</td><td align="center">634210</td><td align="center">豆瓣彩虹组</td><td align="center">2018-04-02</td><td align="center">331574</td><td align="center">娱乐、豆瓣糊组、糊组、影视、明星</td></tr><tr><td align="center">4</td><td align="center">blabla</td><td align="center">豆瓣鹅组</td><td align="center">2010-05-26</td><td align="center">696036</td><td align="center">明星、红人、综艺、影视</td></tr><tr><td align="center">5</td><td align="center">658687</td><td align="center">豆瓣吃瓜组</td><td align="center">2019-03-29</td><td align="center">168458</td><td align="center">娱乐、明星、影视、追剧、生活</td></tr><tr><td align="center">6</td><td align="center">649504</td><td align="center">花路情报局</td><td align="center">2018-11-13</td><td align="center">58578</td><td align="center">情报、女星、电视剧、电影、瓜</td></tr><tr><td align="center">7</td><td align="center">qiqier</td><td align="center">鹅们栖息地</td><td align="center">2010-07-04</td><td align="center">265009</td><td align="center">生活、八卦、影视、明星</td></tr><tr><td align="center">8</td><td align="center">lacai</td><td align="center">豆瓣拉踩小组</td><td align="center">2018-12-06</td><td align="center">55922</td><td align="center">娱乐、明星、爆料、综艺、选秀</td></tr><tr><td align="center">9</td><td align="center">650302</td><td align="center">豆瓣艾玛花园</td><td align="center">2018-11-24</td><td align="center">67215</td><td align="center">娱乐、八卦、爱马士、明星、吃瓜</td></tr><tr><td align="center">10</td><td align="center">664519</td><td align="center">豆瓣九组</td><td align="center">2019-05-31</td><td align="center">150430</td><td align="center">娱乐、八卦、生活、安利</td></tr><tr><td align="center">11</td><td align="center">654153</td><td align="center">自由小组</td><td align="center">2019-01-22</td><td align="center">68584</td><td align="center">娱乐、明星、搞笑、自由、生活</td></tr><tr><td align="center">12</td><td align="center">627382</td><td align="center">豆瓣韩娱</td><td align="center">2017-11-18</td><td align="center">74266</td><td align="center">八卦、娱乐、时尚、明星、韩娱</td></tr><tr><td align="center">13</td><td align="center">673382</td><td align="center">娱乐净土</td><td align="center">2019-09-23</td><td align="center">17013</td><td align="center">娱乐、影视、生活</td></tr><tr><td align="center">14</td><td align="center">646388</td><td align="center">豆瓣婧组、橘组</td><td align="center">2018-09-28</td><td align="center">231645</td><td align="center">青春有你2、选秀、婧组、橘组</td></tr><tr><td align="center">15</td><td align="center">ezu</td><td align="center">鹅组来了</td><td align="center">2018-04-26</td><td align="center">391773</td><td align="center">鹅组、豆瓣鹅组、八卦来了、乐明星红人、综艺影视</td></tr><tr><td align="center">16</td><td align="center">613560</td><td align="center">小象八卦</td><td align="center">2017-03-06</td><td align="center">310227</td><td align="center">闲聊、八卦、网红、淘宝、时尚</td></tr><tr><td align="center">17</td><td align="center">682809</td><td align="center">旧日议事厅</td><td align="center">2020-02-04</td><td align="center">101189</td><td align="center"></td></tr><tr><td align="center">18</td><td align="center">697689</td><td align="center">豆瓣爽组</td><td align="center">2020-06-30</td><td align="center">156781</td><td align="center">娱乐、明星、音乐、影视、时尚</td></tr><tr><td align="center">19</td><td align="center">586674</td><td align="center">生活组</td><td align="center">2016-02-12</td><td align="center">630682</td><td align="center">八卦、亲戚、吐槽</td></tr><tr><td align="center">20</td><td align="center">638298</td><td align="center">哈哈哈哈哈哈哈哈哈哈哈</td><td align="center">2018-06-01</td><td align="center">497544</td><td align="center">笑话、搞笑</td></tr><tr><td align="center">21</td><td align="center">asshole</td><td align="center">我总觉得自己就是一个傻逼</td><td align="center">2007-09-18</td><td align="center">1319749</td><td align="center">傻逼、怪癖、发泄、吐槽、奇闻</td></tr><tr><td align="center">22</td><td align="center">669481</td><td align="center">就等你上车啦！！！</td><td align="center">2019-08-04</td><td align="center">179409</td><td align="center">买、车组、618、大促、上车</td></tr><tr><td align="center">23</td><td align="center">677543</td><td align="center">「人生问题」研究社</td><td align="center">2019-11-15</td><td align="center">163737</td><td align="center">情感、婚姻、工作、职场、人际</td></tr><tr><td align="center">24</td><td align="center">myjob</td><td align="center">上班这件事</td><td align="center">2006-08-17</td><td align="center">572764</td><td align="center">上班、工作、办公室、生活、闲聊</td></tr><tr><td align="center">25</td><td align="center">652046</td><td align="center">豆瓣劝分小组</td><td align="center">2018-12-19</td><td align="center">290091</td><td align="center">情感、恋爱、八卦、吐槽、生活</td></tr></tbody></table><h3 id="topic数据"><a href="#topic数据" class="headerlink" title="topic数据"></a>topic数据</h3><p>字段名称：</p><table><thead><tr><th align="center">序号</th><th align="center">字段</th><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">group</td><td align="center">小组id</td><td align="center">发帖小组</td></tr><tr><td align="center">2</td><td align="center">topic_id</td><td align="center">话题id</td><td align="center">每个话题id</td></tr><tr><td align="center">3</td><td align="center">topic_pub_time</td><td align="center">话题时间</td><td align="center">话题第一次发布时间</td></tr><tr><td align="center">4</td><td align="center">topic_title</td><td align="center">主题名称</td><td align="center">话题发布名称</td></tr><tr><td align="center">5</td><td align="center">topic_owner</td><td align="center">楼主</td><td align="center">话题发布者,用户自定义id</td></tr><tr><td align="center">6</td><td align="center">zan</td><td align="center">点赞数</td><td align="center">话题获得点赞数</td></tr><tr><td align="center">7</td><td align="center">collect</td><td align="center">收藏数</td><td align="center">话题收藏数</td></tr><tr><td align="center">8</td><td align="center">transmit</td><td align="center">转发数</td><td align="center">话题转发数</td></tr></tbody></table><h3 id="reply数据"><a href="#reply数据" class="headerlink" title="reply数据"></a>reply数据</h3><p>字段名称：</p><table><thead><tr><th align="center">序号</th><th align="center">字段</th><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">group</td><td align="center">小组id</td><td align="center">发帖小组</td></tr><tr><td align="center">2</td><td align="center">topic_id</td><td align="center">话题id</td><td align="center">每个话题id</td></tr><tr><td align="center">3</td><td align="center">reply_id</td><td align="center">回复者id</td><td align="center">回复的用户id,原始编号</td></tr><tr><td align="center">4</td><td align="center">reply_pub_time</td><td align="center">时间</td><td align="center">回复时间</td></tr><tr><td align="center">5</td><td align="center">reply_zan</td><td align="center">点赞</td><td align="center">回复收到的点赞数</td></tr><tr><td align="center">6</td><td align="center">reply_id_2</td><td align="center">回复者id</td><td align="center">用户自定义id</td></tr></tbody></table><h3 id="user数据"><a href="#user数据" class="headerlink" title="user数据"></a>user数据</h3><p>字段名称：</p><table><thead><tr><th align="center">序号</th><th align="center">字段</th><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">user_id</td><td align="center">用户id</td><td align="center">活跃用户id</td></tr><tr><td align="center">2</td><td align="center">reg_time</td><td align="center">注册时间</td><td align="center">用户开户时间</td></tr><tr><td align="center">3</td><td align="center">location</td><td align="center">地址</td><td align="center">用户所在城市</td></tr><tr><td align="center">4</td><td align="center">group_num</td><td align="center">加入小组</td><td align="center">用户加入小组总数</td></tr><tr><td align="center">5</td><td align="center">followers</td><td align="center">粉丝数</td><td align="center">用户粉丝数</td></tr><tr><td align="center">6</td><td align="center">books</td><td align="center">读书数</td><td align="center">用户标记的读书数</td></tr><tr><td align="center">7</td><td align="center">movies</td><td align="center">观影数</td><td align="center">用户标记的观影数</td></tr><tr><td align="center">8</td><td align="center">music</td><td align="center">鉴音数</td><td align="center">用户标记的听过的专辑数</td></tr><tr><td align="center">9</td><td align="center">comment</td><td align="center">平均数</td><td align="center">用户的评论数</td></tr><tr><td align="center">10</td><td align="center">photos</td><td align="center">相册数</td><td align="center">用户创建的相册数</td></tr></tbody></table><h1 id="4-目标拆解"><a href="#4-目标拆解" class="headerlink" title="4.目标拆解"></a>4.目标拆解</h1><h2 id="关键指标定义"><a href="#关键指标定义" class="headerlink" title="关键指标定义"></a>关键指标定义</h2><ol><li><strong><em>日均活跃</em></strong>：一天内，用户在该小组有过发帖或回复行为，算作一次活跃，重复行为仅计算一次，按用户id进行去重。</li><li><strong><em>小组成员回复活跃度</em></strong>：小组活跃用户平均发言次数</li><li><strong><em>日均留存率</em></strong>：小组当天活跃人数中，在前一日同样有活跃记录者所占比例（由于是按照帖子id爬取数据，因此只能刻画基于28号、29号发布的帖子留存率）</li><li><strong><em>话题平均回复数</em></strong>：帖子平均回复数，帖子回复数越多，即成员发言意愿更强，说明小组话题质量更高</li><li><strong><em>成员重合度</em></strong>：统计A小组活跃用户中，除A小组外在其余小组中的活跃数占A小组所有活跃数的比例，该指标可以表示小组基本盘大小。</li><li><strong><em>话题质量</em></strong>：反映帖子质量的指标，如帖子平均点赞数、平均收藏数、平均转发数</li><li><strong><em>回复质量</em></strong>：反映回复质量的指标，如最赞top5平均点赞数、全部回复平均点赞数</li><li><strong><em>话题热度延续度</em></strong>：截止数据获取时，话题非当日回复数占所有回复数比例</li><li><strong><em>活跃时间段分布</em></strong>：发帖或回复的时间段</li></ol><h2 id="A-小组活跃维度"><a href="#A-小组活跃维度" class="headerlink" title="A.小组活跃维度"></a>A.小组活跃维度</h2><ol><li>各小组日均活跃人数、成员日均回复活跃度</li><li>各小组日均留存率（更准确说是28号29号发布的帖子对应的用户留存率）</li><li>各小组间成员重合度（小组基本盘大小）</li><li>用户活跃时间段分布</li></ol><h2 id="B-话题质量分析"><a href="#B-话题质量分析" class="headerlink" title="B.话题质量分析"></a>B.话题质量分析</h2><ol start="5"><li>各小组平均日发帖数、话题平均回复数</li><li>各小组帖子质量：帖子平均点赞数、平均收藏数、平均转发数</li><li>各小组回复质量：最赞top5平均点赞数、全部回复平均点赞数</li><li>各小组话题热度延续度</li></ol><h2 id="C-活跃用户画像"><a href="#C-活跃用户画像" class="headerlink" title="C.活跃用户画像"></a>C.活跃用户画像</h2><ol start="9"><li>活跃用户地理分布</li><li>小组活跃用户画像：平均加入小组数、平均豆瓣年龄、平均粉丝数、平均读书数、平均观影数、平均标记专辑数、平均相册数、平均影评数</li></ol><h1 id="5-分析和可视化"><a href="#5-分析和可视化" class="headerlink" title="5.分析和可视化"></a>5.分析和可视化</h1><h2 id="A-小组活跃维度-1"><a href="#A-小组活跃维度-1" class="headerlink" title="A.小组活跃维度"></a>A.小组活跃维度</h2><p>25个小组中，TOP活跃的小组是「豆瓣鹅组」，该小组主要是围绕娱乐、八卦话题讨论的小组，每日平均有1.2w用户参与发言，每位活跃用户每天平均发言4.41次。活跃用户人均发言次数最高的是「旧日议事厅」，为7.55次。</p><blockquote><p><strong><em>活跃用户数和用户发言次数没有明显关联，日均活跃用户数是最重要的衡量小组活跃程度的指标。</em></strong></p></blockquote><p><img src="https://i.loli.net/2021/01/06/Hr8yljJIufZC9WT.png" alt="日均活跃人数.png"><br><img src="https://i.loli.net/2021/01/06/Cmkt4UXseuO691x.png" alt="回复活跃度.png"></p><p>参与28号新帖发言的用户中仍然参与了29号新帖发言的比例最高的是「豆瓣艾玛花园」，达到0.63。从数据可知，大部分小组用户留存率均较高，说明</p><blockquote><p><strong><em>每天活跃在豆瓣各小组的用户基本都是同一批固定的用户。</em></strong></p></blockquote><p><img src="https://i.loli.net/2021/01/06/XsN7FLrT9Cb3Bay.png" alt="留存率.png"></p><ol><li>指标说明，第一行第一列的0.69，表示「豆瓣鹅组」中有69%的用户只在该组发言；</li><li>第一列第二行的0.04，表示「豆瓣鹅组」中有4%的用户在「就等你上车啦」小组中发过言；</li><li>第一行第二列的0.05，表示「就等你上车啦」小组中有5%的用户在「豆瓣鹅组」发过言；</li></ol><blockquote><p>对角线数据的大小可以衡量小组基本盘的大小，从数据可知，各小组的基本盘均较高，说明 <strong><em>豆瓣小组在一定程度上是圈地自萌，具有相同爱好的大部分活跃用户只活跃在所属社区。</em></strong></p></blockquote><p><img src="https://i.loli.net/2021/01/06/iQDbMWqC5EGuHAS.png" alt="成员重合度.png"></p><p>从用户活跃时间段来看，除了凌晨以外，其它时间段均较活跃，最活跃的是晚上21点到23点。</p><p><img src="https://i.loli.net/2021/01/06/fyUwYLNnEboKi2t.png" alt="活跃事件段.png"></p><h2 id="B-话题质量分析-1"><a href="#B-话题质量分析-1" class="headerlink" title="B.话题质量分析"></a>B.话题质量分析</h2><p>小组日发帖数最多的是「就等你上车啦」是远远高于其它小组，可能跟该小组的性质有关，车组主要是团购商品为主，对用户（特别是发帖的楼主）来说往往有利可图，故发帖数较多，其平均回复数仅为20.05，可见该小组确实存在“卖家多买家少”的情况。<br>平均回复数最多的是「豆瓣鹅组」和「小象八卦」，此两小组均为娱乐相关小组，可见  <strong>用户确实热衷于讨论八卦。</strong><br>部分小组发帖数不高但回复数高，如「豆瓣劝分小组」，推测其话题通常教具有吸引力。</p><p><img src="https://i.loli.net/2021/01/06/L4F73UOBspINQtJ.png" alt="平均回复数.png"><br><img src="https://i.loli.net/2021/01/06/kUFytMda6TnDxNR.png" alt="日发帖数.png"></p><p>从帖子质量角度来看，「哈」组绝对一骑绝尘，拥有最高的平均收藏数、转发数和点赞数，说明 <strong>大家都喜欢收藏和分享令人快乐的事物</strong>，其次是「豆瓣鹅组」。<br>从回复质量来看，「豆瓣鹅组」也是遥遥领先，平均每个回复的点赞数为30.52，TOP5（最赞）平均点赞数达301.45。</p><blockquote><p>帖子质量和回复质量是衡量小组话题讨论质量最重要的指标，质量越高越值得“围观”。</p></blockquote><p><img src="https://i.loli.net/2021/01/06/Fg3y8RGQ51OJTEr.png" alt="小组话题质量.png"></p><p>热度延续度是回复中非当日回复占全部回复的比例，其中「人生问题研究社」、「哈」组、「豆瓣劝分小组」和「上班这件事」的延续度最高，这类小组讨论话题通常是讨论人生、家庭等话题，推测因存在用户转发或豆瓣官方推荐产生“二次发布”的效果，故有大量回复并非来自当日。</p><blockquote><p>该指标可以反映豆瓣非小组重度用户感兴趣的话题（方面）。<br>可知娱乐小组的重度用户喜欢圈地自萌，但话题不容易被“推广”，经常是在同一个圈子内发酵。而人生、家庭、工作方面的小组更容易被推广，容易吸引后续用户参与讨论。<br>从产品的角度，<strong>豆瓣算法应该更多的推荐上述小组的热门话题，能吸引更多的书影音用户转化为小组用户。</strong></p></blockquote><p><img src="https://i.loli.net/2021/01/06/2melUW68EZ5GXyh.png" alt="热度延续度.png"></p><h2 id="C-活跃用户画像-1"><a href="#C-活跃用户画像-1" class="headerlink" title="C.活跃用户画像"></a>C.活跃用户画像</h2><p>从上述分析可知，日均活跃用户最多、帖子质量最高的小组是「豆瓣鹅组」，故本文继续爬取28 29号该小组活跃用户24945人的基本数据。</p><p>除去地址为空和填国外的用户，国内用户地理位置分布如下，总体上，东部和南方的活跃用户较多。</p><p><img src="https://i.loli.net/2021/01/06/lvCeopngAtmaLk3.png" alt="地理分布.png"></p><p>豆瓣鹅组活跃于用户画像数据</p><table><thead><tr><th align="center">指标</th><th align="center">平均数</th><th align="center">众数</th><th align="center">中位数</th></tr></thead><tbody><tr><td align="center">加入小组数</td><td align="center">74.8</td><td align="center">22</td><td align="center">51</td></tr><tr><td align="center">豆瓣网龄</td><td align="center">7.51</td><td align="center">9</td><td align="center">8</td></tr><tr><td align="center">粉丝数</td><td align="center">118.81</td><td align="center">2</td><td align="center">17</td></tr><tr><td align="center">读书数</td><td align="center">54.15</td><td align="center">0</td><td align="center">10</td></tr><tr><td align="center">观影数</td><td align="center">356.07</td><td align="center">0</td><td align="center">183</td></tr><tr><td align="center">专辑数</td><td align="center">53.08</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">相册数</td><td align="center">2.28</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><h1 id="6-项目总结"><a href="#6-项目总结" class="headerlink" title="6.项目总结"></a>6.项目总结</h1><p>本文从小组活跃成员维度、帖子质量维度和活跃用户画像维度分析了25个豆瓣小组的数据，分析发现，</p><blockquote><ol><li><strong>活跃用户数和用户发言次数没有明显关联</strong>;</li><li><strong>大部分小组用户留存率均较高，每天活跃在豆瓣各小组的用户基本都是同一批固定的用户</strong>;</li><li><strong>豆瓣小组在一定程度上是圈地自萌，具有相同爱好的大部分活跃用户只活跃在所属社区</strong>;</li><li><strong>大部分活跃用户热衷于讨论八卦，但对人生、家庭、事业相关话题的深度讨论更容易吸引新用户</strong>；</li><li><strong>人们乐于分享和收藏让人开心的事物</strong>；</li><li><strong>豆瓣算法应该更多的推荐上述小组的热门话题，能吸引更多的书影音用户转化为小组用户</strong>；</li><li><strong>中国东部和南方的豆瓣活跃用户更多</strong>。</li></ol></blockquote><p>需要强调的是，所有数据均基于28号29发布的帖子，并不能完整反映小组活跃程度，小组真实活跃情况应远高于本文分析结果。<br>（本文目的旨在练习数据分析思路和熟悉Python代码。）</p><h1 id="7-个人成长"><a href="#7-个人成长" class="headerlink" title="7.个人成长"></a>7.个人成长</h1><p>通过本文的实战，学会了Selenium爬虫基础，巩固了pandas编程，掌握了互联网流量类（社区类）产品的分析方法，达到了本次实战练习的目的。</p><h1 id="8-代码"><a href="#8-代码" class="headerlink" title="8.代码"></a>8.代码</h1><p>github链接<br><a href="https://github.com/TingtingHus/douban-group">https://github.com/TingtingHus/douban-group</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析思维和实战课程学习</title>
      <link href="2020/12/22/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%80%9D%E7%BB%B4%E5%92%8C%E5%AE%9E%E6%88%98/"/>
      <url>2020/12/22/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%80%9D%E7%BB%B4%E5%92%8C%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是拉钩教育课程《数据分析思维与实战》的学习笔记</em></strong></p><p>拉钩教育花木老师的课程，讲解得很具体，很适合初学者和互联网从业者，在很多思维方法上有启发，值得一看。</p><p><img src="https://i.loli.net/2020/12/22/chpuDavJGPifqTQ.png" alt="数据分析思维与实战.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目实战】限五新政对成都二手房市场影响分析与机器学习建模</title>
      <link href="2020/12/18/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%22%E9%99%90%E4%BA%94%22%E6%96%B0%E6%94%BF%E5%AF%B9%E6%88%90%E9%83%BD%E4%BA%8C%E6%89%8B%E6%88%BF%E5%B8%82%E5%9C%BA%E5%BD%B1%E5%93%8D%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BB%BA%E6%A8%A1/"/>
      <url>2020/12/18/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%22%E9%99%90%E4%BA%94%22%E6%96%B0%E6%94%BF%E5%AF%B9%E6%88%90%E9%83%BD%E4%BA%8C%E6%89%8B%E6%88%BF%E5%B8%82%E5%9C%BA%E5%BD%B1%E5%93%8D%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目目的"><a href="#1-项目目的" class="headerlink" title="1.项目目的"></a>1.项目目的</h1><p>1.练习Python编程：通过爬虫获取链家网成都二手房成交数据，并使用Pandas包进行数据清洗、使用PyEcharts包进行绘图、使用sklearn包进行数据建模；<br>2.掌握数据分析思维和方法：分析成都房价现状、限五政策对房价的影响并建立房价影响模型，使用机器学习预测房价；<br>3.完成项目汇总，并总结过程中的经验。</p><h1 id="2-业务理解"><a href="#2-业务理解" class="headerlink" title="2.业务理解"></a>2.业务理解</h1><h2 id="二手房房价的影响因素"><a href="#二手房房价的影响因素" class="headerlink" title="二手房房价的影响因素"></a>二手房房价的影响因素</h2><p>自身因素：位置、面积、户型、层高、属性（住宅或公寓）、房屋年限、装修情况、朝向、挂牌时间、层高等<br>外部因素：交通、政策、物业费、物业口碑等</p><h2 id="成都“限五”新政"><a href="#成都“限五”新政" class="headerlink" title="成都“限五”新政"></a>成都“限五”新政</h2><p>2020.9.14 成都出台“房产新政15条” ，其中要求</p><ol><li>提高公证摇号中棚改、无房居民家庭优先的比例</li><li>发挥税收调节作用，个人住房转让增值税征免年限由2年调整到5年</li></ol><p>新规即日起执行。</p><h3 id="政策解读"><a href="#政策解读" class="headerlink" title="政策解读"></a>政策解读</h3><p>提高无房家庭优先摇号的比例有助于刚需购房者购置新房，同时将征免年限提高到5年会大大增加二手房转让的成本，猜想新政对成都二手房市场有较大冲击，购房者会更多的选择”满五“的二手房以降低税费。</p><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><p>本文通过对2020年6月到10月的成都二手房成交数据的分析和建模，旨在研究成都房价现状、限五政策对房价的影响，并建立机器学习模型。</p><h1 id="3-数据爬取"><a href="#3-数据爬取" class="headerlink" title="3.数据爬取"></a>3.数据爬取</h1><p>利用Python的requests+BeautifulSoup库爬取链家网成都二手房成交数据<a href="https://cd.lianjia.com/chengjiao/">https://cd.lianjia.com/chengjiao/</a><br>时间选取2020年6月到10月数据集。<br>（仅研究成都一圈层二手房市场，即锦江、青羊、武侯、高新、成华、金牛、天府新区、高新西，共8个区）<br>数据字段：</p><table><thead><tr><th align="center">序号</th><th align="center">字段</th><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">id</td><td align="center">二手房ID</td><td align="center">12位数字</td></tr><tr><td align="center">2</td><td align="center">domain</td><td align="center">房屋属性</td><td align="center">本文均为二手房</td></tr><tr><td align="center">3</td><td align="center">tenant_id</td><td align="center">区域</td><td align="center">第一圈层共8区</td></tr><tr><td align="center">4</td><td align="center">name</td><td align="center">小区名</td><td align="center">房屋所在小区名</td></tr><tr><td align="center">5</td><td align="center">type</td><td align="center">房屋类型</td><td align="center">如普通住宅、车库等</td></tr><tr><td align="center">6</td><td align="center">deal_dt</td><td align="center">成交日期</td><td align="center">如2020.09.05</td></tr><tr><td align="center">7</td><td align="center">location</td><td align="center">所在区</td><td align="center">同tenant_id</td></tr><tr><td align="center">8</td><td align="center">sub_location</td><td align="center">二级地址</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">area</td><td align="center">面积</td><td align="center">如85.77㎡，单位平方米</td></tr><tr><td align="center">10</td><td align="center">class</td><td align="center">户型</td><td align="center">如3室</td></tr><tr><td align="center">11</td><td align="center">avg_price</td><td align="center">均价</td><td align="center">每平米平均价格（元）</td></tr><tr><td align="center">12</td><td align="center">total_price</td><td align="center">成交价</td><td align="center">如169万（万元）</td></tr><tr><td align="center">13</td><td align="center">used_price</td><td align="center">挂牌价</td><td align="center">如169（万）</td></tr><tr><td align="center">14</td><td align="center">period</td><td align="center">挂牌时长</td><td align="center">如98（天）</td></tr><tr><td align="center">15</td><td align="center">change_time</td><td align="center">调价次数</td><td align="center">如2（次）</td></tr><tr><td align="center">16</td><td align="center">introduce</td><td align="center">带看次数</td><td align="center">如19（次）</td></tr><tr><td align="center">17</td><td align="center">follower</td><td align="center">关注人数</td><td align="center">如42（人）</td></tr><tr><td align="center">18</td><td align="center">views</td><td align="center">浏览次数</td><td align="center">2152（次）</td></tr><tr><td align="center">19</td><td align="center">build_time</td><td align="center">建成年代</td><td align="center">如2014</td></tr><tr><td align="center">20</td><td align="center">zhuangxiu</td><td align="center">装修情况</td><td align="center">精装</td></tr><tr><td align="center">21</td><td align="center">show_time</td><td align="center">挂牌时间</td><td align="center">如2020-05-31</td></tr><tr><td align="center">22</td><td align="center">years</td><td align="center">是否满五</td><td align="center">如满五年</td></tr><tr><td align="center">23</td><td align="center">other</td><td align="center">房权所属</td><td align="center">如非共有、共有</td></tr></tbody></table><h1 id="4-目标拆解与建模"><a href="#4-目标拆解与建模" class="headerlink" title="4.目标拆解与建模"></a>4.目标拆解与建模</h1><h2 id="A-二手房市场现状"><a href="#A-二手房市场现状" class="headerlink" title="A.二手房市场现状"></a>A.二手房市场现状</h2><p>通过描述性分析展现房价现状</p><ol><li>各区二手房成交量（折线图堆叠，时间/数量）</li><li>各区房价及挂牌价与成交价之差走势（折线柱状混合，时间/房价）</li><li>房屋年限及满2满5占比走势（折线柱状混合，时间/天数）</li><li>各区二手房平均挂牌天数图（柱状图，时间/天数）</li><li>各区价格平均更改次数、平均带看次数（折线图堆叠，时间/天数）</li></ol><h2 id="B-二手房价格影响因素"><a href="#B-二手房价格影响因素" class="headerlink" title="B.二手房价格影响因素"></a>B.二手房价格影响因素</h2><p>自变量：</p><table><thead><tr><th align="center">序号</th><th align="center">字段</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">tenant_id</td><td align="center">区域（分类变量）</td></tr><tr><td align="center">2</td><td align="center">type</td><td align="center">房屋类型，住宅或公寓、别墅（分类变量）</td></tr><tr><td align="center">3</td><td align="center">area</td><td align="center">面积</td></tr><tr><td align="center">4</td><td align="center">class</td><td align="center">户型</td></tr><tr><td align="center">5</td><td align="center">period</td><td align="center">挂牌时长（天）</td></tr><tr><td align="center">6</td><td align="center">change_time</td><td align="center">调价次数</td></tr><tr><td align="center">7</td><td align="center">introduce</td><td align="center">带看次数</td></tr><tr><td align="center">8</td><td align="center">build_diff</td><td align="center">建成时长（年）</td></tr><tr><td align="center">9</td><td align="center">zhuangxiu</td><td align="center">装修情况（分类变量）</td></tr></tbody></table><p>因变量：成交平均价（每平米元）avg_price<br>模型：线性回归</p><h2 id="C-政策对房价的影响"><a href="#C-政策对房价的影响" class="headerlink" title="C.政策对房价的影响"></a>C.政策对房价的影响</h2><p>自变量：同上，增加时间虚拟变量tag（914后=1，914前=0）<br>因变量：成交平均价（每平米元）avg_price<br>模型：线性回归</p><h2 id="D-二手房房价预测"><a href="#D-二手房房价预测" class="headerlink" title="D.二手房房价预测"></a>D.二手房房价预测</h2><p>方法：机器学习之随机森林、线性回归、支持向量机<br>变量：同上，增加关注人数、带看次数、浏览次数、成交周期、调价次数、成交价</p><h1 id="5-结论与可视化"><a href="#5-结论与可视化" class="headerlink" title="5.结论与可视化"></a>5.结论与可视化</h1><h2 id="A-二手房市场现状-1"><a href="#A-二手房市场现状-1" class="headerlink" title="A.二手房市场现状"></a>A.二手房市场现状</h2><p><img src="https://i.loli.net/2020/12/18/gr6sOR12b59tPNp.png" alt="各区二手房成交量.png"></p><ol><li>在一圈层8个区中，青羊区和成华区成交量最高，高新西和天府新区成交量最低；</li><li>9月新政颁布后，除高新西区外，二手房成交量有明显下降趋势，其中，天府新区和锦江区下降幅度最大。</li></ol><blockquote><p>天府新区成交量低且新政后下降幅度最大，说明该区二手房市场并不吃香且受新政影响较大。</p></blockquote><p><img src="https://i.loli.net/2020/12/18/FLwavVfOXNI4tER.png" alt="各区房价及差价走势.png"></p><ol><li>二手房平均成交价最高的区为高新区和锦江区，最低的为高新西区和金牛区；</li><li>所有区的平均挂牌价都高于实际平均成交价，其中挂牌溢价最高的是天府新区和锦江区，挂牌价最接近实际成交价的区是高新西区和成华区；</li><li>9月新政颁布后，10月份部分区房价波动不大，如武侯和高新西区，部分区有小幅下降，其中，下降幅度最大的是锦江区，10月平均每平米下降1639元。</li></ol><blockquote><p>高新西区不仅成交量最低且平均房价也最低，说明高新西区的二手房并不受到购房者的追捧；<br>溢价最高的天府新区成交量也低，说明购房者对天府新区的二手房市场持谨慎购买的态度；<br>成交量最高的成华区的溢价不明显（挂牌价接近成交价），且平均房价处于中位，说明该区二手房市场处在良性供求关系中，性价比较高；<br>新政短期内对二手房市场呈微弱抑制作用，平均房价有小幅下降；<br>新政对溢价最高的锦江区影响最大，平均每平米下降1639元，可见新政使高溢价区的二手房价实现了价值回归。</p></blockquote><p><img src="https://i.loli.net/2020/12/18/ZD8ca4CEkLufvbY.png" alt="平均调价和带看次数.png"></p><ol><li>二手房平均调价次数最多的是金牛区，达到5.23次，调价次数最少的是锦江区，为3.28次；</li><li>带看次数最多的是青羊区，为38.59次，带看次数最多的是高新西区，为33.31次，这与成交量有关，高新西区的成交量低势必带看次数也低。</li></ol><blockquote><p>结合平均房价看，锦江区平均房价高，市场卖方占优势，故调价次数少，而金牛区则相反，平均房价低，买方占主导，故调价次数多。</p></blockquote><p><img src="https://i.loli.net/2020/12/18/MFsaPqWnR8EVHof.png" alt="房屋建成年限走势.png"></p><ol><li>9月新政颁布前，二手房平均年限稳定为11年，新政颁布后，该年限提升为12年；</li><li>新政将征免年限提高到5年后，二手房“满五”成交的比例明显上升。</li></ol><blockquote><p>数据印证了猜想，新政后购房者确实更多的选择满五年的二手房，以减少税费。</p></blockquote><p><img src="https://i.loli.net/2020/12/18/7oLa2wApnvr5xQl.png" alt="各区挂牌天数.png"></p><ol><li>各区二手房平均挂牌天数最长的高新区和天府新区，挂牌时间最短的是成华区和青羊区。</li></ol><blockquote><p>挂牌天数和成交量高度相关，成交量高的挂牌时间就短，反之成交量低的挂牌时间长。</p></blockquote><h2 id="B-二手房价格影响因素-1"><a href="#B-二手房价格影响因素-1" class="headerlink" title="B.二手房价格影响因素"></a>B.二手房价格影响因素</h2><p>根据线性回归结果，</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avgPrice = 5.82*area+913.22*class-0.63*period-70.25*changeTime+1.94*introduce-310.87*buildDiff+3886.94*tenantIdGaoxin-5141.21*tenantIdGaoxinxi+4696.53*tenantIdJinjiang-1214.46*tenantIdJinniu+3651.31*tenantIdQingyang-134.72*tenantIdTianfuxinqu+592.20*tenantIdWuhou +4743.10*typeZhuzhai+1381.77*zhuangxiuJingzhuang+167.11*zhuangxiuMaopi+930.46*zhuangxiuOther+11991.34</span><br></pre></td></tr></tbody></table></figure><p>然而，模型的回归R-squared仅有0.457，说明模型的解释效果并不好，缺失重要的自变量。</p><h2 id="C-政策对房价的影响-1"><a href="#C-政策对房价的影响-1" class="headerlink" title="C.政策对房价的影响"></a>C.政策对房价的影响</h2><p>增加政策发生时间分类变量tag=1表示914后，为0表示914前，回归结果如下，</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avgPrice = 95.20*tag_1+5.80*area+914.51*class-0.62*period-70.54*changeTime+1.94*introduce-311.20*buildDiff+3895.52*tenantIdGaoxin-5110.73*tenantIdGaoxinxi+4709.82*tenantIdJinjiang-1204.03*tenantIdJinniu+3653.54*tenantIdQingyang-119.33*tenantIdTianfuxinqu+601.58*tenantIdWuhou+4747.34*typeZhuzhai+1382.24*zhuangxiuJingzhuang+169.98*zhuangxiuMaopi+936.04*zhuangxiuOther+11954.10</span><br></pre></td></tr></tbody></table></figure><blockquote><p>回归结果显示tag为1的系数为正，新政颁布后的平均房价增加？对该变量进行显著性分析，P值为0.174，可见并不显著；<br>查看该模型的回归R-squared仅0.457，说明模型的解释效果并不好，缺失重要的自变量，且时间分类变量tag系数不显著，因此并不能得出新政颁布后的平均房价增加的结论。<br>结合前文二手房市场现状的分析可知，新政颁布后，部分区房价有小幅下降，总体上新政短期对二手房市场影响不显著，呈现微弱抑制效果，但不排除为季节性波动。</p></blockquote><h2 id="D-二手房房价预测-1"><a href="#D-二手房房价预测-1" class="headerlink" title="D.二手房房价预测"></a>D.二手房房价预测</h2><p>本文采用了随机森林、SVM、线性回归三种机器学习方法进行模型训练，三种模型效果如下</p><table><thead><tr><th align="center">指标</th><th align="center">随机森林</th><th align="center">线性回归</th><th align="center">SVM</th></tr></thead><tbody><tr><td align="center">R-squared</td><td align="center">0.839</td><td align="center">0.728</td><td align="center">0.717</td></tr><tr><td align="center">MSE</td><td align="center">10970641</td><td align="center">18556599</td><td align="center">19285611</td></tr><tr><td align="center">MAE</td><td align="center">2007</td><td align="center">2795</td><td align="center">2790</td></tr><tr><td align="center">RMSE</td><td align="center">3312</td><td align="center">4307</td><td align="center">4391</td></tr></tbody></table><blockquote><p>从模型评价指标来说，随机森林表现最为优异，SVM和线性回归不相上下，但是从学习曲线来看，线性回归拟合效果最好，随机森林出现过拟合。因此该二手房成交房价预测模型适合用线性回归建模。</p></blockquote><p><img src="https://i.loli.net/2020/12/18/TCWXkQBs4fjJRve.png" alt="E0945CA4-102D-4A44-B64B-924FDAFC4E9D.png"><br><img src="https://i.loli.net/2020/12/18/gs6qvfMzbRYOwL2.png" alt="线性模型学习曲线.png"></p><h1 id="6-项目总结"><a href="#6-项目总结" class="headerlink" title="6.项目总结"></a>6.项目总结</h1><h2 id="研究结论"><a href="#研究结论" class="headerlink" title="研究结论"></a>研究结论</h2><p>2020.9.14 成都出台“房产新政15条”，本文通过对2020年6月到10月的成都一圈层8个区二手房成交数据的分析和建模，发现</p><ol><li>天府新区成交量低、溢价高且新政后成交量下降幅度最大，说明该区二手房市场并不吃香且受新政影响较大，购房者对天府新区的二手房持谨慎购买的态度。</li><li>成交量最高的成华区的溢价不明显（挂牌价接近成交价），且平均房价处于中位，说明该区二手房市场处在良性供求关系中，在8个区中性价比较高；</li><li>高新西区不仅成交量最低且平均房价也最低，说明高新西区的二手房并不受到购房者的追捧。</li><li>新政对溢价最高的锦江区影响最大，平均每平米下降1639元，说明新政使高溢价区的二手房价实现了价值回归。</li><li>新政短期内对对二手房市场影响不显著，呈微弱抑制效果，平均房价有小幅下降。</li></ol><h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><p>通过本项目的练习，我更加熟悉了Python编程，特别是在Pandas、PyEcharts有显著进步，对sklearn也更了解；同时掌握了基本的数据分析方法和步骤。通过此研究，完成了成都二手房房价现状以及新政对房价影响的研究并形成了文档总结，总体来说收获颇丰。</p><h1 id="7-代码"><a href="#7-代码" class="headerlink" title="7.代码"></a>7.代码</h1><p>github</p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium自动化测试</title>
      <link href="2020/12/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ASelenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>2020/12/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ASelenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是阅读书籍《Selenium自动化测试(公版)》后，整理了涉及Selenium的相关笔记。</em></strong></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本书侧重于讲解基于 Selenium 开源程序的网络爬虫方面的自动化技术。<br>Selenium 项目最早是为了测试浏览器、网页而诞生的，而在大数据的时代，Selenium 则被广泛应用于网络爬虫。</p><p>如果要选择 web 方面的自动化工具的话， selenium 应该作为首选（一个支持多种浏览器，多种操作系统，多种编程语言的工具，恐怕没有什么比它更合适了）。</p><h1 id="Selenium基础"><a href="#Selenium基础" class="headerlink" title="Selenium基础"></a>Selenium基础</h1><h2 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></tbody></table></figure><h2 id="安装Webdriver"><a href="#安装Webdriver" class="headerlink" title="安装Webdriver"></a>安装Webdriver</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入 selenuim 库</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">#下面一行代码用于启动 Chrome 浏览器</span></span><br><span class="line">driver = webdriver.Chrome()</span><br></pre></td></tr></tbody></table></figure><h2 id="打开页面"><a href="#打开页面" class="headerlink" title="打开页面"></a>打开页面</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入 selenuim 库和键盘操作</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="comment">#打开 Chrome 浏览器</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment">#打开百度页面</span></span><br><span class="line">driver.get(<span class="string">"https://baidu.com"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="可以设置打开页面的大小"><a href="#可以设置打开页面的大小" class="headerlink" title="可以设置打开页面的大小"></a>可以设置打开页面的大小</h3><p>默认打开窗口较小</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置打开页面的长和宽</span></span><br><span class="line">driver.set_window_size(<span class="number">800</span>, <span class="number">480</span>)</span><br><span class="line"><span class="comment">#最大化</span></span><br><span class="line">driver.maximize_window()</span><br></pre></td></tr></tbody></table></figure><h2 id="浏览器基本操作-前进、后退、刷新和关闭"><a href="#浏览器基本操作-前进、后退、刷新和关闭" class="headerlink" title="浏览器基本操作:前进、后退、刷新和关闭"></a>浏览器基本操作:前进、后退、刷新和关闭</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入 selenium 库和时间库</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#打开浏览器和百度页面</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://baidu.com"</span>)</span><br><span class="line"><span class="comment">#在停留两秒后打开百度新闻</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.get(<span class="string">"http://news.baidu.com"</span>)</span><br><span class="line"><span class="comment">#在停留两秒后后退</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment">#在停留两秒后前进</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.forward()</span><br><span class="line"><span class="comment">#在停留两秒后刷新</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.refresh()</span><br><span class="line"><span class="comment">#在停留两秒后关闭浏览器</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="滑动页面"><a href="#滑动页面" class="headerlink" title="滑动页面"></a>滑动页面</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://baidu.com"</span>)</span><br><span class="line"><span class="comment">#停留两秒</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#执行 JavaScript 代码</span></span><br><span class="line">JS=<span class="string">"window.scrollTo(10000,document.body.scrollHeight)"</span></span><br><span class="line">driver.execute_script(JS)</span><br><span class="line"><span class="comment">#停留两秒后退出</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="调用Cookie"><a href="#调用Cookie" class="headerlink" title="调用Cookie"></a>调用Cookie</h2><p>常用cookie的方法</p><blockquote><p>get_cookies(): 获得所有 cookie 信息。<br>delete_all_cookies():删除所有 cookie 信息。<br>get_cookie([name])：返回字典的 key 为[name]的 cookie<br>add_cookie(cookie_dict):添加 cookie。“cookie_dict”指字典对象，必须有 name 和<br>value 两个值。<br>delete_cookie([name],[optionsString]):删除 cookie 信息。[name]是要删除的 cookie<br>的名称。第二个参数[optionsString]是 cookie 选项，目前支持的选项包括“路径”，<br>“域”</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line"><span class="comment">#这里通过查找元素实现搜索</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line"><span class="comment">#获取所有 cookie</span></span><br><span class="line">cookies=driver.get_cookies()</span><br><span class="line"><span class="comment">#返回字典的 key 为的 BAIDUID 的 cookie</span></span><br><span class="line">cookie=driver.get_cookie(<span class="string">"BAIDUID"</span>)</span><br><span class="line">print(cookies)</span><br><span class="line">print(cookie)</span><br><span class="line"><span class="comment">#删除所有 cookie 信息。</span></span><br><span class="line">driver.delete_all_cookies()</span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="打开多个窗口"><a href="#打开多个窗口" class="headerlink" title="打开多个窗口"></a>打开多个窗口</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#打开浏览器，窗口最大化</span></span><br><span class="line">driver=webdriver.Chrome()</span><br><span class="line">driver.maximize_window() <span class="comment">#</span></span><br><span class="line">driver.get(<span class="string">"http://baidu.com"</span>)</span><br><span class="line"><span class="comment">#停留两秒后打开搜狗搜索</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">JS1=<span class="string">'window.open("https://www.sogou.com");'</span></span><br><span class="line">driver.execute_script(JS1)   <span class="comment">#在当前窗口/框架 同步执行JavaScript</span></span><br><span class="line"><span class="comment">#停留两秒后打开有道翻译</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">JS2=<span class="string">'window.open("https://fanyi.youdao.com/");'</span></span><br><span class="line">driver.execute_script(JS2)</span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line"><span class="comment">#driver.quit()</span></span><br></pre></td></tr></tbody></table></figure><h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><p>HTML元素就是 HTML 文件的一个基本组成单元，HTML 元素涵盖的内容包括但不仅限于：文字、图片、音频、动画、视频。<br>Selenium 提供了 8 种定位方式。</p><blockquote><p>ID<br>name<br>class name<br>tag name<br>link text<br>partial link text<br>xpath<br>css selector</p></blockquote><p>这 8 种定位方式在 Python selenium 中所对应的方法为：</p><blockquote><p>find_element_by_id() <strong>推荐</strong><br>find_element_by_name()<br>find_element_by_class_name()<br>find_element_by_tag_name()<br>find_element_by_link_text()<br>find_element_by_partial_link_text()<br>find_element_by_xpath() <strong>推荐</strong><br>find_element_by_css_selector()</p></blockquote><h2 id="1-根据ID定位-推荐）"><a href="#1-根据ID定位-推荐）" class="headerlink" title="1.根据ID定位(推荐）"></a>1.根据ID定位(推荐）</h2><p>带有特定 ID 值的 HTML元素可以被 CSS（Cascading Style Sheets，层叠样式表）样式选择器和 JavaScript 脚本查找到。<br>一般为了便于区分在 <strong>HTML 页面中是不会设置 ID 相同的 HTML 元素</strong>。并且 HTML元素 ID 如果重名，也有相当严重的后果。</p><p>这里是百度的搜索框的代码：<br><code>&lt;input type="text" class="s_ipt" name="wd" id="kw" maxlength="100" autocomplete="off"&gt; </code><br>重点在这里，ID=”kw”，好，我们就从这里知道了，百度搜索框的 ID 为 kw，以后，我们就可以找到这个 ID 了。<br>再来看一下搜索确认按钮的 ID：<br><code>&lt;input type="submit" value="百度一下" id="su" class="btn self-btn bg s_btn"&gt; </code><br>通过上面这段代码我们可以看到，ID=”su”，那么，万事具备了。我们来进行一个实际操作。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#打开浏览器和打开百度</span></span><br><span class="line">driver=webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://www.baIDu.com/"</span>)</span><br><span class="line"><span class="comment">#通过 ID 查找，然后输入，并点击</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"selenium"</span>)  <span class="comment">#send_key()是一个方法，意思是向搜索框发出特定的字符串</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click() <span class="comment">#click()是一个方法，用于向某个特定的HTML元素发送确认请求</span></span><br><span class="line"><span class="comment">#退出浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="2-根据Name定位"><a href="#2-根据Name定位" class="headerlink" title="2.根据Name定位"></a>2.根据Name定位</h2><p>ID 就像是一个人的身份证号码，而 Name 就像是他的名字，ID 的值显然是唯一的，而 Name 的值却是可以重复的<br>我们用 find_element_by_name()来实现刚才的功能，再来看以下刚才的代码，搜索框中的代码存在：<br><code>&lt;input type="text" class="s_ipt" name="wd" id="kw" maxlength="100" autocomplete="off"&gt; </code><br>这个 HTML 标签有个一个属性——name=”wd”，很明显，这个 wd 就是我们所需要查找的。<br>我们考虑这一行代码来实现相同的功能：<br><code>driver.find_element_by_name("wd") </code><br>因为点击按钮所在的 HTML 标签并不存在 name 属性，所以我们无法通过查找 name 属性来找到这个元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过 name 查找，然后输入</span></span><br><span class="line">driver.find_element_by_name(<span class="string">"wd"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line"><span class="comment">#通过 id 查找并点击</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#退出浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="3-根据XPath定位-推荐）"><a href="#3-根据XPath定位-推荐）" class="headerlink" title="3.根据XPath定位(推荐）"></a>3.根据XPath定位(推荐）</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line"><span class="comment">#通过 XPath 查找，然后输入</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">r'//*[@id="kw"]'</span>).send_keys(<span class="string">"selenium"</span>)  <span class="comment"># 使用 r’’来转义，单引号和XPath的双引号区分</span></span><br><span class="line"><span class="comment">#通过 id 查找并点击</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#退出浏览器</span></span><br><span class="line">driver.quit()     </span><br></pre></td></tr></tbody></table></figure><h3 id="获取html标签中的href元素"><a href="#获取html标签中的href元素" class="headerlink" title="获取html标签中的href元素"></a>获取html标签中的href元素</h3><p><code>driver.find_element_by_xpath(r'//*[@id="g-side-info"]/div[1]/div/a').get_attribute('href')</code></p><h2 id="4-根据Tag-Name定位（不建议）"><a href="#4-根据Tag-Name定位（不建议）" class="headerlink" title="4.根据Tag Name定位（不建议）"></a>4.根据Tag Name定位（不建议）</h2><p>我们以这个标签为例子：<br><code>&lt;em class="show-city-name" data-key="郑州"&gt; 郑州： &lt;/em&gt; </code><br>Em 就是标签名，而后面的 class=”show-city-name” data-key=”郑州”则是这个标签的属性，一个标签可以跟着多个属性，但只能有一个标签名。<strong>一个 HTML 页面中，可能会有很多的相同的标签。</strong><br><code>find_element_by_tag_name</code><br><strong>不建议使用，因为通常会有多个相同标签</strong></p><h2 id="5-根据Class-Name定位（不建议）"><a href="#5-根据Class-Name定位（不建议）" class="headerlink" title="5.根据Class Name定位（不建议）"></a>5.根据Class Name定位（不建议）</h2><p>Class 作为 HTML 标签的属性，规定元素的类名，绝大多数的 class 标签都是用于指向 CSS 中的类。可以同时给一个HTML标签附上多个类，比如说，这样的写法 ：<br><code>&lt;span class="left_menu important"&gt;</code>，同时将 left_menu 和 important 赋给 span 标签（中间的空格叫做间隔符号，表示的是一个标签有多个 class 的属性名称）</p><p>由于 Selenium 现在的版本已经不再支持复合类名,只接受传输的参数是一个class类名，<strong>因此本方法也不建议使用</strong>（有解决方案但不建议）</p><p>比如当有多个符合class时， <code>&lt;input type="text" class="s_ipt bg s_btn" name="wd" id="kw" autocomplete="off"&gt;</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line"><span class="comment">#calss 名查找搜索框</span></span><br><span class="line">driver.find_element_by_class_name(<span class="string">"s_ipt"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line">elements = driver.find_elements_by_tag_name(<span class="string">'input'</span>)</span><br><span class="line">print(elements)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    className = element.get_attribute(<span class="string">'class'</span>)</span><br><span class="line">    print(className)</span><br><span class="line">    <span class="keyword">if</span> className == <span class="string">'bg s_btn'</span>:</span><br><span class="line">        subscript=elements.index(element)</span><br><span class="line">elements[subscript].click()</span><br></pre></td></tr></tbody></table></figure><h2 id="6-根据CSS定位"><a href="#6-根据CSS定位" class="headerlink" title="6.根据CSS定位"></a>6.根据CSS定位</h2><p>即Copy selector</p><blockquote><p>“[name=wd]”表示选择所有 name 属性为 wd 的元素（虽然这个页面只有一个）<br>“#kw”，选择 id 为 kw 的元素（id 是唯一的，你只能选择到一个）<br>“[src^=”http”]”，选择所有以 http 作为 src 开头的元素<br>“html &gt; body &gt; form &gt; span &gt; input”，从标签 html 中选出标签 body，再以此类推，直到选择 input 标签<br>“.s_ipt”，表示选择所有 class 属性为 s_ipt 的标签，不要忽略了前面的点，前面的点才是关键的<br>“span.soutu-btn&gt; input#kw”像这种则是复合写法，首先查找到class属性中含有soutu-btn的span标签，然后进去span标签的子元素中查找id为kw的input标签</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line"><span class="comment">#clss 名查找搜索框</span></span><br><span class="line">driver.find_element_by_css_selector(<span class="string">"#kw"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line">driver.find_element_by_css_selector(<span class="string">"#su"</span>).click()</span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="7-根据Link-Text定位"><a href="#7-根据Link-Text定位" class="headerlink" title="7.根据Link Text定位"></a>7.根据Link Text定位</h2><p>Link text 定位方法定位的是带有超链接的文字。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开新闻</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.find_element_by_link_text(<span class="string">"新闻"</span>).click()</span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment">#打开地图</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.find_element_by_link_text(<span class="string">"地图"</span>).click()</span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment">#打开视频</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.find_element_by_link_text(<span class="string">"视频"</span>).click()</span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="8-根据Partial-Link-Text定位"><a href="#8-根据Partial-Link-Text定位" class="headerlink" title="8.根据Partial Link Text定位"></a>8.根据Partial Link Text定位</h2><p>部分文字定位主要用于网站的文字会经常变化，但读者可以确定包含某个特定字符</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开新闻</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.find_element_by_partial_link_text(<span class="string">"新"</span>).click()</span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment">#打开地图</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.find_element_by_partial_link_text(<span class="string">"地"</span>).click()</span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment">#打开视频</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.find_element_by_partial_link_text(<span class="string">"视"</span>).click()</span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h1 id="PhantomJS"><a href="#PhantomJS" class="headerlink" title="PhantomJS"></a>PhantomJS</h1><p>selenium是python的一个第三方自动化测试库，也非常适合用来写爬虫，而PhantomJS是其子包Webdriver下面的一个浏览器接口，除了 PhantomJS浏览器，Webdriver 还整合了Chrome、Firefox、IE等浏览器，并提供了操作这些浏览器的接口。<br>因PhantomJS也称无界面浏览器，不需要界面的同时占用的内存也相对较小，更适用于大规模多进程爬数据（开几十个Chrome进程爬数据，那真是内存噩梦！）。<br>简单容易上手的selenium库，是爬动态网页的杀手级武器，加上PhantomJS威力就更大了。</p><p>Selenium 中 PhantomJS的主要功能类似于其他的Webdriver，<strong>最大的特点在于使用时不会有浏览器页面窗口弹出操作</strong>，占用顶层窗口，也不需要获取焦点。</p><p>安装了PhantomJS后只需两行代码就可以启动：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">obj = webdriver.PhantomJS()</span><br></pre></td></tr></tbody></table></figure><h2 id="PhantomJS-Selenium实例"><a href="#PhantomJS-Selenium实例" class="headerlink" title="PhantomJS+Selenium实例"></a>PhantomJS+Selenium实例</h2><p>在这个例子中，首先我们创建 PhantomJS 浏览器对象，然后打开 Bing 搜索，首先打印出页面标题，然后在搜索框中输入字符串，截图，点击搜索，截图，点开搜索结果的第一个页面</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 webdriver</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 要想调用键盘按键操作需要引入 keys 包</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="comment"># 调用环境变量指定的 PhantomJS 浏览器创建浏览器对象</span></span><br><span class="line">driver = webdriver.PhantomJS()</span><br><span class="line"><span class="comment"># get 方法会一直等到页面被完全加载，</span></span><br><span class="line"><span class="comment">#然后才会继续程序，通常测试会在这里选择 time.sleep(2)</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.get(<span class="string">"http://cn.bing.com/"</span>)</span><br><span class="line"><span class="comment">#打印页面标题</span></span><br><span class="line">title_=driver.title</span><br><span class="line">print(title_)</span><br><span class="line"><span class="comment"># id="sb_form_q"是 bing 搜索输入框，输入字符串"SELENIUM 自动化测试"</span></span><br><span class="line">keywords = <span class="string">'SELENIUM 自动化测试'</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"sb_form_q"</span>).send_keys(keywords)</span><br><span class="line"><span class="comment"># 生成当前页面快照并保存</span></span><br><span class="line">driver.save_screenshot(<span class="string">"bing_1.png"</span>)</span><br><span class="line"><span class="comment">#点击搜索按钮</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"sb_form_go"</span>).click()</span><br><span class="line"><span class="comment"># 生成当前页面快照并保存</span></span><br><span class="line">driver.save_screenshot(<span class="string">"bing_2.png"</span>)</span><br><span class="line"><span class="comment"># 进行当前页面点击第一项</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"/html/body/div/ol/li/h2/a"</span>).click()</span><br><span class="line"><span class="comment"># 生成当前页面快照并保存，在这里由于没有页面重定位，仍停留在这个页面</span></span><br><span class="line">driver.save_screenshot(<span class="string">"bing_3.png"</span>)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></tbody></table></figure><h3 id="PhantomJS调用"><a href="#PhantomJS调用" class="headerlink" title="PhantomJS调用"></a>PhantomJS调用</h3><p>driver = webdriver.PhantomJS() ,该语句默认调用环境变量指定的 PhantomJS 浏览器创建浏览器对象，如果没有在环境变量指定 PhantomJS 位置，这里应该指定为你 phantomjs 的安装路径，直接指向 bin 文件夹下的 exe 文件，使用如下语句：<br>driver = webdriver.PhantomJS(executable_path=”【path】”)</p><h3 id="Selenium退出"><a href="#Selenium退出" class="headerlink" title="Selenium退出"></a>Selenium退出</h3><p>Selenium 中含有两种退出方法，分别是 close 方法和 quit 方法，区别在于关闭 driver时使用了 driver.close(),close方法关闭后并不会清除临时文件中的 webdriver临时文件。用 driver.quit(),quit 关闭浏览器后，会自动删除临时文件夹。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="unable-to-find-element-with-id-‘kw’"><a href="#unable-to-find-element-with-id-‘kw’" class="headerlink" title="unable to find element with id ‘kw’"></a>unable to find element with id ‘kw’</h3><p>可能读者可以在页面源码确实发现某些元素，但通过selenium的元素查找方法find_element_by_xpath(),find_element_by_id()等类似定位函数无法获得该元素对象，比如说提示“unable to find element with id ‘kw’”的错误。那么可能会存在一种特殊情况，<strong>元素被包裹在一个特定的frame中</strong>。<br>如果如此，那么你还需要首先使用：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Frame_name= driver.find_element_by_id(【Frame_name】)</span><br><span class="line">driver.switch_to_frame(Frame_name)</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，读者在切换到这个 frame 之后，只能访问当前 frame 的内容，如果想要回到默认内容（默认的 frame），selenium 中有一个函数是专门为这种情况准备的：<br><code>driver.switch_to_default_content()</code></p><h3 id="PhantomJS进程不自动退出"><a href="#PhantomJS进程不自动退出" class="headerlink" title="PhantomJS进程不自动退出"></a>PhantomJS进程不自动退出</h3><p>主程序退出后，selenium 不能也无法保证 PhantomJS 也成功退出，笔者在这里建议读者最好手动关闭 PhantomJS 进程。下面一行代码可以帮助你免除这个麻烦：<br><code>driver.quit()</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sklearn机器学习笔记</title>
      <link href="2020/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Asklearn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Asklearn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是使用sklearn包后，整理的笔记，参考来源有<br>1.<a href="https://www.cnblogs.com/helongBlog/p/11612128.html">https://www.cnblogs.com/helongBlog/p/11612128.html</a><br>2.<a href="https://blog.csdn.net/zhw864680355/article/details/102544188">https://blog.csdn.net/zhw864680355/article/details/102544188</a><br>3.<a href="https://zhuanlan.zhihu.com/p/38622109">https://zhuanlan.zhihu.com/p/38622109</a></em></strong></p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>sklearn中规定必须导入数值型</p><h2 id="1-重复值处理"><a href="#1-重复值处理" class="headerlink" title="1.重复值处理"></a>1.重复值处理</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_df1 = df.drop_duplicates() <span class="comment"># 删除数据记录中所有列值相同的记录</span></span><br><span class="line">new_df2 = df.drop_duplicates([<span class="string">'col1'</span>]) <span class="comment"># 删除数据记录中col1值相同的记录</span></span><br><span class="line">new_df3 = df.drop_duplicates([<span class="string">'col2'</span>]) <span class="comment"># 删除数据记录中col2值相同的记录</span></span><br><span class="line">new_df4 = df.drop_duplicates([<span class="string">'col1'</span>, <span class="string">'col2'</span>]) <span class="comment"># 删除数据记录中指定列（col1/col2）值相同的记录</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-缺失值"><a href="#2-缺失值" class="headerlink" title="2.缺失值"></a>2.缺失值</h2><p>当样本量够大的时候，建议直接删除缺失数据行</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_new = df.dropna() <span class="comment">#不存在的值，删除整行</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-时间变量datetime处理"><a href="#3-时间变量datetime处理" class="headerlink" title="3.时间变量datetime处理"></a>3.时间变量datetime处理</h2><p>利用datetime自身性质拆分成年、月、日、时、分、秒</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">house_df[<span class="string">'deal_year'</span>] = house_df[<span class="string">'deal_dt'</span>].dt.year</span><br><span class="line">house_df[<span class="string">'deal_month'</span>] = house_df[<span class="string">'deal_dt'</span>].dt.month</span><br><span class="line">house_df[<span class="string">'deal_day'</span>] = house_df[<span class="string">'deal_dt'</span>].dt.day</span><br></pre></td></tr></tbody></table></figure><h2 id="4-处理分类变量"><a href="#4-处理分类变量" class="headerlink" title="4.处理分类变量"></a>4.处理分类变量</h2><p>采用pandas自带的get_dummies方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># drop_first会自动删除虚拟变量，避免多重共线性</span></span><br><span class="line">df_dummy_ref = pd.get_dummies(df[[<span class="string">'x1'</span>,<span class="string">'sex'</span>,<span class="string">'day'</span>]],drop_first=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="5-连续到二分变量"><a href="#5-连续到二分变量" class="headerlink" title="5.连续到二分变量"></a>5.连续到二分变量</h2><p>可采用pandas自带的cut方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'incoming'</span>] = pd.cut(df[<span class="string">'FamilyIncoming'</span>],[<span class="number">0</span>,<span class="number">100000</span>,df[<span class="string">'FamilyIncoming'</span>].<span class="built_in">max</span>()],labels=[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="6-划分训练集和测试集"><a href="#6-划分训练集和测试集" class="headerlink" title="6.划分训练集和测试集"></a>6.划分训练集和测试集</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="7-数据标准化（无量纲化）"><a href="#7-数据标准化（无量纲化）" class="headerlink" title="7.数据标准化（无量纲化）"></a>7.数据标准化（无量纲化）</h2><p>譬如逻辑回归，支持向量机，神经网络，无量纲化可以加快求解速度；而在距离类模型，譬如K近邻，K-Means聚类中，无量纲化可以帮我们提升模型精度，避免某一个取值范围特别大的特征对距离计算造成影响。<br>（一个特例是决策树和树的集成算法们，对决策树我们不需要无量纲化，决策树可以把任意数据都处理得很好。）</p><p>数据的无量纲化可以是线性的，也可以是非线性的。线性的无量纲化包括中心化（Zero-centered或者Mean-subtraction）处理和缩放处理（Scale）。</p><blockquote><p>中心化的本质是让所有记录减去一个固定值，即让数据样本数据平移到某个位置。<br>缩放的本质是通过除以一个固定值，将数据固定在某个范围之中，取对数也算是一种缩放处理。</p></blockquote><p>数据归一化(Min-Max Scaling)。注意，Normalization是归一化，不是正则化。归一化之后的数据服从正态分布。<br>特殊的，当数据(x)按均值(μ)中心化后，再按标准差(σ)缩放，数据就会服从为均值为0，方差为1的正态分布（即标准正态分布），而这个过程，就叫做数据标准化(Standardization，又称Z-score normalization)。</p><p>大多数机器学习算法中，会选择StandardScaler来进行特征缩放，因为MinMaxScaler对异常值非常敏感。在PCA，聚类，逻辑回归，支持向量机，神经网络这些算法中，StandardScaler往往是最好的选择。</p><p>下面是对普通数组的标准化</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">print(data)</span><br><span class="line">scaler = StandardScaler()  <span class="comment"># 实例化</span></span><br><span class="line">scaler.fit(data)  <span class="comment"># fit，本质是生成均值和方差</span></span><br><span class="line">print(scaler.mean_)  <span class="comment"># 查看均值的属性mean_</span></span><br><span class="line">print(scaler.var_)  <span class="comment"># 查看方差的属性var_</span></span><br><span class="line"></span><br><span class="line">x_std = scaler.transform(data)  <span class="comment"># 通过接口导出结果</span></span><br><span class="line">print(x_std.mean())  <span class="comment"># 导出的结果是一个数组，用mean()查看均值</span></span><br><span class="line">print(x_std.std())  <span class="comment"># 用std()查看方差</span></span><br><span class="line"></span><br><span class="line">print(scaler.fit_transform(data))  <span class="comment"># 使用fit_transform(data)一步达成结果</span></span><br><span class="line">print(scaler.inverse_transform(x_std))  <span class="comment"># 使用inverse_transform逆转标准化</span></span><br></pre></td></tr></tbody></table></figure><h3 id="训练集和测试集是否应该使用相同的预处理：是"><a href="#训练集和测试集是否应该使用相同的预处理：是" class="headerlink" title="训练集和测试集是否应该使用相同的预处理：是"></a>训练集和测试集是否应该使用相同的预处理：是</h3><p>机器学习算法是建立在training和test data服从同一/类似分布的假设之上的。所以有一条准则：预处理对于training和test data要保持一致。如果预处理不同，那怎么还能保证training和test data分布一致</p><h3 id="归一化时，是否应该将训练集和测试集混合计算：否"><a href="#归一化时，是否应该将训练集和测试集混合计算：否" class="headerlink" title="归一化时，是否应该将训练集和测试集混合计算：否"></a>归一化时，是否应该将训练集和测试集混合计算：否</h3><p>在machine learning中，test data原则上是与training data独立的数据集。它的目的是验证在training data上训练好的模型是否在完全独立的，未知的数据集上有相同的表现。做归一化时，如果将test data和training data混合一起计算了，那么归一化之后的training data就相包含了test data的信息。这样就打破了test data应该与training data独立的原则。再者，在真正的工业应用中，你的test data可能是在你模型部署之后一个个采集的：有可能今天来10个，明天来6个，后天来1个。这种情况下如果将training和test data一起用来计算做归一化，那岂不是每天采集一次数据都要计算一次，再重新训练？</p><p>综合以上两点，在做归一化时，普遍的做法是只用training data计算数据如均值，方差，主成分，等，然后用保存好的计算数据对test data进行归一化。</p><h3 id="X和y分开标准化"><a href="#X和y分开标准化" class="headerlink" title="X和y分开标准化"></a>X和y分开标准化</h3><p>其实每一列就是分开的</p><p>下面是机器学习中的标准化</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler_X = StandardScaler()</span><br><span class="line">X_train_z = scaler_X.fit_transform(X_train)</span><br><span class="line">scaler_y = StandardScaler()</span><br><span class="line">y_train_z = scaler_y.fit_transform(y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用训练集的数据均值、方差归一化测试集，以便数据满足同分布</span></span><br><span class="line">X_test_z = scaler_X.fit_transform(X_test)</span><br><span class="line">y_test_z = scaler_y.fit_transform(y_test)</span><br></pre></td></tr></tbody></table></figure><h2 id="可选8-字段相关系数-可忽略"><a href="#可选8-字段相关系数-可忽略" class="headerlink" title="可选8.字段相关系数(可忽略)"></a>可选8.字段相关系数(可忽略)</h2><p>当数据维度很多时可以考虑先查看相关系数，挑选相关性最强的维度进行训练，避免过拟合</p><h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><h2 id="SVF"><a href="#SVF" class="headerlink" title="SVF"></a>SVF</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从sklearn.svm中导入支持向量机回归模型SVR</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"><span class="comment">#1.使用线性核函数配置的支持向量机进行回归训练并预测</span></span><br><span class="line">linear_svr = SVR(kernel=<span class="string">'linear'</span>)</span><br><span class="line">linear_svr.fit(X_train,y_train)</span><br><span class="line">linear_svr_y_predict = linear_svr.predict(X_test)</span><br><span class="line"><span class="comment">#2.使用多项式核函数配置的支持向量机进行回归训练并预测</span></span><br><span class="line">poly_svr = SVR(kernel=<span class="string">'poly'</span>)</span><br><span class="line">poly_svr.fit(X_train,y_train)</span><br><span class="line">poly_svr_y_predict = poly_svr.predict(X_test)</span><br><span class="line"><span class="comment">#3.使用径向基核函数配置的支持向量机进行回归训练并预测</span></span><br><span class="line">rbf_svr = SVR(kernel=<span class="string">'rbf'</span>)</span><br><span class="line">rbf_svr.fit(X_train,y_train)</span><br><span class="line">rbf_svr_y_predict = rbf_svr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对三种核函数配置下的支持向量机回归模型在相同测试集下进行性能评估</span></span><br><span class="line"><span class="comment">#使用R-squared、MSE、MAE指标评估</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score,mean_absolute_error,mean_squared_error</span><br><span class="line"><span class="comment">#1.线性核函数配置的SVR</span></span><br><span class="line">print(<span class="string">'R-squared value of linear SVR is'</span>,linear_svr.score(X_test,y_test))</span><br><span class="line">print(<span class="string">'the MSE of linear SVR is'</span>,mean_squared_error(ss_y.inverse_transform(y_test),ss_y.inverse_transform(linear_svr_y_predict)))</span><br><span class="line">print(<span class="string">'the MAE of linear SVR is'</span>,mean_absolute_error(ss_y.inverse_transform(y_test),ss_y.inverse_transform(linear_svr_y_predict)))</span><br><span class="line"><span class="comment">#2.多项式核函数配置的SVR</span></span><br><span class="line">print(<span class="string">'R-squared value of Poly SVR is'</span>,poly_svr.score(X_test,y_test))</span><br><span class="line">print(<span class="string">'the MSE of Poly SVR is'</span>,mean_squared_error(ss_y.inverse_transform(y_test),ss_y.inverse_transform(poly_svr_y_predict)))</span><br><span class="line"><span class="built_in">print</span> <span class="string">'the MAE of Poly SVR is'</span>,mean_absolute_error(ss_y.inverse_transform(y_test),ss_y.inverse_transform(poly_svr_y_predict)))</span><br><span class="line"><span class="comment">#3.径向基核函数配置的SVR</span></span><br><span class="line">print(<span class="string">'R-squared value of RBF SVR is'</span>,rbf_svr.score(X_test,y_test)</span><br><span class="line">print(<span class="string">'the MSE of RBF SVR is'</span>,mean_squared_error(ss_y.inverse_transform(y_test),ss_y.inverse_transform(rbf_svr_y_predict)))</span><br><span class="line">print(<span class="string">'the MAE of RBF SVR is'</span>,mean_absolute_error(ss_y.inverse_transform(y_test),ss_y.inverse_transform(rbf_svr_y_predict)))</span><br></pre></td></tr></tbody></table></figure><h2 id="线性回归预测"><a href="#线性回归预测" class="headerlink" title="线性回归预测"></a>线性回归预测</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选择基于梯度下降的线性回归模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">LR_reg = LinearRegression()</span><br><span class="line"><span class="comment">#进行拟合</span></span><br><span class="line">LR_reg.fit(X_train,y_train)</span><br><span class="line">LR_reg.predict(X_test)</span><br></pre></td></tr></tbody></table></figure><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line">rf = RandomForestRegressor()</span><br><span class="line">rf.fit(X_train,y_train)</span><br><span class="line">rf_t_pred = rf.predict(X_test)</span><br></pre></td></tr></tbody></table></figure><h1 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h1><h2 id="画预测值和真实值图形"><a href="#画预测值和真实值图形" class="headerlink" title="画预测值和真实值图形"></a>画预测值和真实值图形</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plot.figure(figsize=(<span class="number">10</span>,<span class="number">7</span>))       <span class="comment">#画布大小</span></span><br><span class="line">num=<span class="number">100</span></span><br><span class="line">x=np.arange(<span class="number">1</span>,num+<span class="number">1</span>)              <span class="comment">#取100个点进行比较</span></span><br><span class="line">plot.plot(x,target[:num],label=<span class="string">'target'</span>)      <span class="comment">#目标取值</span></span><br><span class="line">plot.plot(x,preds[:num],label=<span class="string">'preds'</span>)        <span class="comment">#预测取值</span></span><br><span class="line">plot.legend(loc=<span class="string">'upper right'</span>)  <span class="comment">#线条显示位置</span></span><br><span class="line">plot.show()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机选取100个真实值和预测值，进行绘图比较</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_y_pred_test</span>(<span class="params">y_tst,y_pred</span>):</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">7</span>))  <span class="comment"># 画布大小</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    x = np.arange(<span class="number">1</span>, num + <span class="number">1</span>)  <span class="comment"># 取100个点进行比较</span></span><br><span class="line">    num_list = np.random.randint(<span class="number">0</span>,<span class="built_in">len</span>(y_tst),size=<span class="number">100</span>)</span><br><span class="line">    y_tst_new = []</span><br><span class="line">    y_pred_new = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        y_tst_new.append(y_tst.iloc[i])</span><br><span class="line">        y_pred_new.append(y_pred[i])</span><br><span class="line">    plt.plot(x,y_tst_new, label=<span class="string">'target'</span>)  <span class="comment"># 目标取值</span></span><br><span class="line">    plt.plot(x,y_pred_new, label=<span class="string">'predict'</span>)  <span class="comment"># 预测取值</span></span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>)  <span class="comment"># 线条显示位置</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></tbody></table></figure><h2 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h2><p>在画学习曲线时，横轴为训练样本的数量，纵轴为准确率。学习曲线就是通过画出不同训练集大小时训练集和交叉验证的准确率，可以看到模型在新数据上的表现，进而来判断模型是否方差偏高或偏差过高，以及增大训练集是否可以减小过拟合。</p><p>当训练集和测试集的误差收敛但却很高时，为高偏差。<br>左上角的偏差很高，训练集和验证集的准确率都很低，很可能是欠拟合。我们可以增加模型参数，比如，构建更多的特征，减小正则项。 此时通过增加数据量是不起作用的。</p><p>当训练集和测试集的误差之间有大的差距时，为高方差。<br>当训练集的准确率比其他独立数据集上的测试结果的准确率要高时，一般都是过拟合。 我们可以增大训练集，降低模型复杂度，增大正则项，或者通过特征选择减少特征数。</p><p>理想情况是是找到偏差和方差都很小的情况，即收敛且误差较小。</p><p>首先定义画出学习曲线的方法，<br>核心就是调用了 sklearn.model_selection 的 learning_curve，<br>学习曲线返回的是 train_sizes, train_scores, test_scores，<br>画训练集的曲线时，横轴为 train_sizes, 纵轴为 train_scores_mean，<br>画测试集的曲线时，横轴为 train_sizes, 纵轴为 test_scores_mean</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv : 做cross-validation的时候，数据分成的份数，其中一份作为cv集，其余n-1份作为training(默认为5份)</span></span><br><span class="line"><span class="comment"># model就是fit后的结果</span></span><br><span class="line"><span class="comment"># ylim : tuple格式的(ymin, ymax), 设定图像中纵坐标的最低点和最高点</span></span><br><span class="line">train_size, train_score, test_score = learning_curve(model1, X_train, Y_train, cv=<span class="number">10</span>, train_sizes=np.linspace(<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">5</span>))  </span><br><span class="line"></span><br><span class="line">train_scores_mean = np.mean(train_score, axis=<span class="number">1</span>)</span><br><span class="line">train_scores_std = np.std(train_score, axis=<span class="number">1</span>)</span><br><span class="line">test_scores_mean = np.mean(test_score, axis=<span class="number">1</span>)</span><br><span class="line">test_scores_std = np.std(test_score, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.fill_between(train_size, train_scores_mean - train_scores_std,</span><br><span class="line">                     train_scores_mean + train_scores_std, alpha=<span class="number">0.1</span>,</span><br><span class="line">                     color=<span class="string">"r"</span>)</span><br><span class="line">plt.fill_between(train_size, test_scores_mean - test_scores_std,</span><br><span class="line">                     test_scores_mean + test_scores_std, alpha=<span class="number">0.1</span>, color=<span class="string">"g"</span>)</span><br><span class="line">plt.plot(train_size, train_scores_mean, <span class="string">'o--'</span>, color=<span class="string">"r"</span>,</span><br><span class="line">             label=<span class="string">"Training score"</span>)</span><br><span class="line">plt.plot(train_size, test_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"g"</span>,</span><br><span class="line">             label=<span class="string">"Cross-validation score"</span>)</span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">'Learn Curve'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">"best"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="回归评价指标"><a href="#回归评价指标" class="headerlink" title="回归评价指标"></a>回归评价指标</h2><h3 id="均方误差（MSE）"><a href="#均方误差（MSE）" class="headerlink" title="均方误差（MSE）"></a>均方误差（MSE）</h3><p>MSE （Mean Squared Error）叫做均方误差，用（ 真实值-预测值 ）然后平方之后求和平均，也就是线性回归的损失函数，在线性回归的时候我们的目的就是让这个损失函数最小。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line">mean_squared_error(scaler_y.inverse_transform(y_test), scaler_y.inverse_transform(y_pred))</span><br></pre></td></tr></tbody></table></figure><h3 id="均方根误差（RMSE）"><a href="#均方根误差（RMSE）" class="headerlink" title="均方根误差（RMSE）"></a>均方根误差（RMSE）</h3><p>即MSE开个根号么，其实实质是一样的，只不过用于数据更好的描述。<br>例如：要做房价预测，每平方是万元（真贵），我们预测结果也是万元。那么差值的平方单位应该是 千万级别的，因此最好就开个根号，我们误差的结果就跟我们数据是一个级别的了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line">np.sqrt(mean_squared_error(scaler_y.inverse_transform(y_test_rmse), scaler_y.inverse_transform(y_pred)))</span><br></pre></td></tr></tbody></table></figure><h3 id="MAE-平均绝对误差"><a href="#MAE-平均绝对误差" class="headerlink" title="MAE(平均绝对误差)"></a>MAE(平均绝对误差)</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> median_absolute_error</span><br><span class="line">mean_absolute_error(scaler_y.inverse_transform(y_test), scaler_y.inverse_transform(y_pred))</span><br></pre></td></tr></tbody></table></figure><h3 id="R-Squared"><a href="#R-Squared" class="headerlink" title="R Squared"></a>R Squared</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test,y_pred)</span><br></pre></td></tr></tbody></table></figure><p>1减去（均方误差MSE 除以 方差 ）</p><p>分子就是我们训练出的模型预测的所有误差。<br>分母就是不管什么我们猜的结果就是y的平均数。（瞎猜的误差）</p><p>如果结果是0，就说明我们的模型跟瞎猜差不多。<br>如果结果是1。就说明我们模型无错误。<br>如果结果是0-1之间的数，就是我们模型的好坏程度。<br>如果结果是负数。说明我们的模型还不如瞎猜。（其实导致这种情况说明我们的数据其实没有啥线性关系）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析与可视化讲解课程学习</title>
      <link href="2020/11/13/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%B2%E8%A7%A3/"/>
      <url>2020/11/13/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是拉钩教育《数据分析与可视化讲解》课程的学习笔记。</em></strong></p><h1 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h1><blockquote><p>内容主要围绕PyEcharts框架结合案例进行讲解，重要突出可视化部分；第一个模块也讲解了数据分析的方法体系和流程、步骤，对比了狭义的数据分析和数据挖掘的区别和联系；最后一个模块是PyEcharts+Flask框架进行数据分布。总的来说学习后可以对PyEcharts框架有一定的了解。</p></blockquote><h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h1 id="第一节-什么是数据分析可视化"><a href="#第一节-什么是数据分析可视化" class="headerlink" title="第一节 什么是数据分析可视化"></a>第一节 什么是数据分析可视化</h1><p>数据分析与数据挖掘<br><img src="https://i.loli.net/2020/11/13/w3rph87yedSYiIz.png" alt="数据分析与数据挖掘.png"><br>数据可视化分析<br><img src="https://i.loli.net/2020/11/13/ZPSk6nfsJ3XgcYV.png" alt="数据可视化分析.png"><br>常用的数据分析图表<br><img src="https://i.loli.net/2020/11/13/UlehGEtKSF7di9y.png" alt="常用数据分析表‘.png"></p><h1 id="第二节-数据可视化分析的方法体系"><a href="#第二节-数据可视化分析的方法体系" class="headerlink" title="第二节 数据可视化分析的方法体系"></a>第二节 数据可视化分析的方法体系</h1><h2 id="四大目标"><a href="#四大目标" class="headerlink" title="四大目标"></a>四大目标</h2><p>数据分析可视化是围绕业务问题解决的过程，分为4个环节：呈现业务、发现问题、分析问题、定位原因。</p><h3 id="呈现业务"><a href="#呈现业务" class="headerlink" title="呈现业务"></a>呈现业务</h3><p>包括实时的业务数据、数据历史的变化趋势、数据的空间分布和数据构成分布等，为发现业务问题打好基础</p><h3 id="发现异常"><a href="#发现异常" class="headerlink" title="发现异常"></a>发现异常</h3><p>包括对⽐差异、时间变化趋势、空间分布和构成结构上的异常等，都属于异常。这⼀环节可以⼈⼯完成，也可以系统⾃动完成，⼀般的数据可视化系统都会集成异常数据监控能⼒（即异常预警）。</p><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>通过时间维度、空间维度、结构维度和关系维度，分析引起异常的可能原因，并进⾏逐⼀验证。</p><h3 id="定位原因"><a href="#定位原因" class="headerlink" title="定位原因"></a>定位原因</h3><p>基于数据表现，制定对应的产品和运营策略，通过A/B测试的模式，来验证假设，对于分析问题过程中的推论进⾏业务验证，从⽽发现根本原因。例如，当你发现商品的价格因素可能是导致销量下降的原因的时候，可以通过适当的降价/促销等营销活动，来验证这个假设是否成⽴。</p><h2 id="常用工作方法"><a href="#常用工作方法" class="headerlink" title="常用工作方法"></a>常用工作方法</h2><p>专家法、参照法、归纳法、混合法<br>围绕业务进⾏分析，服务于业务、解决业务问题，是该⼯作必须坚持的核⼼原则</p><h2 id="七大操作流程"><a href="#七大操作流程" class="headerlink" title="七大操作流程"></a>七大操作流程</h2><h3 id="1-业务理解"><a href="#1-业务理解" class="headerlink" title="1.业务理解"></a>1.业务理解</h3><h3 id="2-定义指标"><a href="#2-定义指标" class="headerlink" title="2.定义指标"></a>2.定义指标</h3><p>业务⼝径<br>计算逻辑，业务指标的技术⼝径，对应完整的SQL查询语句和对应的聚合逻辑<br>权限控制</p><h3 id="3-定义维度（即分析维度）"><a href="#3-定义维度（即分析维度）" class="headerlink" title="3.定义维度（即分析维度）"></a>3.定义维度（即分析维度）</h3><p>常⻅的分析维度包括对⽐维度、分布维度、构成维度和关系维度等</p><h3 id="4-设计呈现"><a href="#4-设计呈现" class="headerlink" title="4.设计呈现"></a>4.设计呈现</h3><p>基于已定义的指标和维度，设计⻚⾯布局、选择可视图表、设计主题样式和数据交互模式，进⾏数据可视化呈现的过程。该步骤的核⼼在于可视化图表的选择，常⻅的可视化图表包括：折线图、柱状图、散点图等，每个图表适⽤的场景不同。</p><h3 id="5-程序设计（即可视化落地）"><a href="#5-程序设计（即可视化落地）" class="headerlink" title="5.程序设计（即可视化落地）"></a>5.程序设计（即可视化落地）</h3><h3 id="6-数据发布"><a href="#6-数据发布" class="headerlink" title="6.数据发布"></a>6.数据发布</h3><h3 id="7-分析洞察"><a href="#7-分析洞察" class="headerlink" title="7.分析洞察"></a>7.分析洞察</h3><p>基于构建的数据可视化图表，进⾏问题发现、问题分析和定位原因的过程</p><h1 id="第三节-数据分析可视化的两类技术"><a href="#第三节-数据分析可视化的两类技术" class="headerlink" title="第三节 数据分析可视化的两类技术"></a>第三节 数据分析可视化的两类技术</h1><p><img src="https://i.loli.net/2020/11/13/XsQNVcm6AtuEwIH.png" alt="数据分析可视化的两类技术.png"></p><h2 id="Readsh核心功能"><a href="#Readsh核心功能" class="headerlink" title="Readsh核心功能"></a>Readsh核心功能</h2><h3 id="数据源管理"><a href="#数据源管理" class="headerlink" title="数据源管理"></a>数据源管理</h3><h3 id="SQL即席查询"><a href="#SQL即席查询" class="headerlink" title="SQL即席查询"></a>SQL即席查询</h3><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h3 id="数据仪表盘"><a href="#数据仪表盘" class="headerlink" title="数据仪表盘"></a>数据仪表盘</h3><p>Ubuntu环境下安装，Redash的核⼼价值在于SQL查询和报表设计，如果不考虑交互体验，其核⼼功能满⾜80%的需求，是没问题的。且Redash的仪表盘⽀持定时刷新机制</p><h1 id="第四节-Echarts数据可视化基础"><a href="#第四节-Echarts数据可视化基础" class="headerlink" title="第四节 Echarts数据可视化基础"></a>第四节 Echarts数据可视化基础</h1><p>Echarts是⼀个开源的、免费的、成熟的、商业级的图表可视化框架，它基于JavaScript语⾔开发，是国内使⽤最多和最为⼴泛的可视化图表框架之⼀。是事实上的⾏业标准。主要优势有：</p><h3 id="图表类型丰富"><a href="#图表类型丰富" class="headerlink" title="图表类型丰富"></a>图表类型丰富</h3><h3 id="主题样式美观"><a href="#主题样式美观" class="headerlink" title="主题样式美观"></a>主题样式美观</h3><h3 id="源码开源免费"><a href="#源码开源免费" class="headerlink" title="源码开源免费"></a>源码开源免费</h3><h3 id="⽂档教程完备"><a href="#⽂档教程完备" class="headerlink" title="⽂档教程完备"></a>⽂档教程完备</h3><h3 id="技术社区活跃"><a href="#技术社区活跃" class="headerlink" title="技术社区活跃"></a>技术社区活跃</h3><h3 id="Echarts的导入"><a href="#Echarts的导入" class="headerlink" title="Echarts的导入"></a>Echarts的导入</h3><p>使⽤Echarts图表组件库之前，需要引⼊对应的JavaScript库⽂件。⽂件的引⼊⽅式有本地引⼊和远程引⼊。本地引⼊是需要把Echarts库⽂件下载到本地服务器，远程引⼊是通过⽹络⽅式，引⼊第三⽅提供的Echarts⽂件，⽤得最多的就是由百度提供Echarts库⽂件</p><h2 id="Echarts开发步骤"><a href="#Echarts开发步骤" class="headerlink" title="Echarts开发步骤"></a>Echarts开发步骤</h2><p>Echarts图表开发的过程主要分为四个步骤：</p><h3 id="1-Echarts⽂件引⼊"><a href="#1-Echarts⽂件引⼊" class="headerlink" title="1.Echarts⽂件引⼊"></a>1.Echarts⽂件引⼊</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;head&gt;</span><br><span class="line"><span class="number">2.</span>&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line"><span class="number">3.</span>&nbsp;&nbsp;&lt;!--&nbsp;引⼊&nbsp;echarts.js&nbsp;--&gt;</span><br><span class="line">4.&nbsp;&nbsp;&lt;script src="https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js"&gt;&lt;/script &gt;&nbsp; # 远程导入</span><br><span class="line"><span class="number">5.</span>&lt;/head&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="2-HTML-DOM对象声明"><a href="#2-HTML-DOM对象声明" class="headerlink" title="2.HTML DOM对象声明"></a>2.HTML DOM对象声明</h3><p>定义⼀个HTML DOM对象，⽤来作为Echarts图表元素的容器.对象声明就是声明⼀个带有ID属性的占位符DIV，占位符名称为：”container”，并且赋予了⼀个⾼度属性。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;div&nbsp;id=<span class="string">"container"</span>&nbsp;style=<span class="string">"height:&nbsp;100%"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们需要完成的⼯作是** Echarts对象绑定**，绑定的代码只有⼀⾏</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span><span class="keyword">var</span>&nbsp;dom&nbsp;=&nbsp;<span class="built_in">document</span>.getElementById(<span class="string">"container"</span>);</span><br></pre></td></tr></tbody></table></figure><p>上述代码，实现了⻚⾯元素”container”与JavaScript变量dom之间的关系绑定，完成对象绑定后，<br>对于变量操作，可以直接作⽤到对应的⻚⾯对象上</p><h3 id="3-图表对象初始化"><a href="#3-图表对象初始化" class="headerlink" title="3.图表对象初始化"></a>3.图表对象初始化</h3><p>⾸先声明了⼀个变量dom，完成⻚⾯元素与Javascript变量之间的关联，然后创建⼀个Echarts图表对象myChart，并进⾏初始化</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;script&nbsp;type=<span class="string">"text/javascript"</span>]]&gt;</span><br><span class="line"><span class="number">2.</span><span class="keyword">var</span>&nbsp;dom&nbsp;=&nbsp;<span class="built_in">document</span>.getElementById(<span class="string">"container"</span>);</span><br><span class="line"><span class="number">3.</span><span class="keyword">var</span>&nbsp;myChart&nbsp;=&nbsp;echarts.init(dom);</span><br><span class="line"><span class="number">4.</span><span class="keyword">var</span>&nbsp;app&nbsp;=&nbsp;{};</span><br></pre></td></tr></tbody></table></figure><h3 id="4-参数设置"><a href="#4-参数设置" class="headerlink" title="4.参数设置"></a>4.参数设置</h3><p>接下来进⾏myChart图表对象的参数设置，其中option是图表的参数对象，其中xAxis、yAxis代表坐标轴x和y轴的设置，series代表的是图表的数值系列。此处为了简化程序的复杂度，我们把option属性参数写成了固定内容，实际⼯作中，需要根据业务需求进⾏数据内容的替换。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span>option&nbsp;=&nbsp;<span class="literal">null</span>;</span><br><span class="line"><span class="number">6.</span>option&nbsp;=&nbsp;{</span><br><span class="line"><span class="number">7.</span>&nbsp;&nbsp;&nbsp;&nbsp;xAxis:&nbsp;{</span><br><span class="line"><span class="number">8.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;<span class="string">'category'</span>,</span><br><span class="line"><span class="number">9.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;[<span class="string">'Mon'</span>,&nbsp;<span class="string">'Tue'</span>,&nbsp;<span class="string">'Wed'</span>,&nbsp;<span class="string">'Thu'</span>,&nbsp;<span class="string">'Fri'</span>,&nbsp;<span class="string">'Sat'</span>,&nbsp;<span class="string">'Sun'</span>]</span><br><span class="line"><span class="number">10.</span>&nbsp;&nbsp;&nbsp;&nbsp;},</span><br><span class="line"><span class="number">11.</span>&nbsp;&nbsp;&nbsp;&nbsp;yAxis:&nbsp;{</span><br><span class="line"><span class="number">12.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;<span class="string">'value'</span></span><br><span class="line"><span class="number">13.</span>&nbsp;&nbsp;&nbsp;&nbsp;},</span><br><span class="line"><span class="number">14.</span>&nbsp;&nbsp;&nbsp;&nbsp;series:&nbsp;[{</span><br><span class="line"><span class="number">15.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;[<span class="number">120</span>,&nbsp;<span class="number">200</span>,&nbsp;<span class="number">150</span>,&nbsp;<span class="number">80</span>,&nbsp;<span class="number">70</span>,&nbsp;<span class="number">110</span>,&nbsp;<span class="number">130</span>],</span><br><span class="line"><span class="number">16.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;<span class="string">'bar'</span>,</span><br><span class="line"><span class="number">17.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showBackground:&nbsp;<span class="literal">true</span>,</span><br><span class="line"><span class="number">18.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backgroundStyle:&nbsp;{</span><br><span class="line"><span class="number">19.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;<span class="string">'rgba(220,&nbsp;220,&nbsp;220,&nbsp;0.8)'</span></span><br><span class="line"><span class="number">20.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br><span class="line"><span class="number">21.</span>&nbsp;&nbsp;&nbsp;&nbsp;}]</span><br><span class="line"><span class="number">22.</span>};</span><br><span class="line"><span class="number">23.</span>;</span><br><span class="line"><span class="number">24.</span><span class="keyword">if</span>&nbsp;(option&nbsp;&amp;&amp;&nbsp;<span class="keyword">typeof</span>&nbsp;option&nbsp;===&nbsp;<span class="string">"object"</span>)&nbsp;{</span><br><span class="line"><span class="number">25.</span>&nbsp;&nbsp;&nbsp;&nbsp;myChart.setOption(option,&nbsp;<span class="literal">true</span>);</span><br><span class="line"><span class="number">26.</span>}</span><br><span class="line"><span class="number">27.</span>&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="第五节-PyEcharts数据可视化环境"><a href="#第五节-PyEcharts数据可视化环境" class="headerlink" title="第五节 PyEcharts数据可视化环境"></a>第五节 PyEcharts数据可视化环境</h1><p>PyEcharts是Echarts数据可视化框架，在Python开发语⾔环境下的实现版本，借助PyEcharts，开发者可<br>以使⽤Python语⾔直接⽣成可视化图表。PyEcharts的特点：<br>基于Python语⾔设计<br>图表类型丰富<br>源码开源免费：PyEcharts是⼀个开源项⽬，可以免费⽤于商业⽤途。<br>⽂档教程健全<br>Web集成⽅便：PyEcharts可以很轻松地和Flask、Django等Web框架整合，以Web⻚⾯的⽅式呈现，便于跨团队、跨部⻔、跨地域的合作和分享。</p><h2 id="PyEcharts配置"><a href="#PyEcharts配置" class="headerlink" title="PyEcharts配置"></a>PyEcharts配置</h2><p>PyEcharts的配置主要是图表的参数设置，内容包括图表的提示框组件参数、图例组件参数、⼯具箱组件参数、X轴组件参数、Y轴组件参数、数据缩放组件参数、视图效果组件参数和主题样式参数，配置好的参数最终体现在可视化的图表中，⼀个典型的图表参数与⻚⾯呈现图表地对应关系，如下图所示：<br><img src="https://i.loli.net/2020/11/13/Vz6egFmIftLq1MO.png" alt="PyEcharts配置.png"></p><h2 id="PyEcharts开发过程"><a href="#PyEcharts开发过程" class="headerlink" title="PyEcharts开发过程"></a>PyEcharts开发过程</h2><p>PyEcharts图表开发的过程主要分为四个步骤：PyEcharts图表组件引⼊、图表对象声明、图表对象参数设置、图表对象渲染。</p><h3 id="1-PyEcharts图表组件引⼊"><a href="#1-PyEcharts图表组件引⼊" class="headerlink" title="1.PyEcharts图表组件引⼊"></a>1.PyEcharts图表组件引⼊</h3><p>如，在源码中，引⼊PyEcharts柱状图组件<br>from pyecharts.charts import Bar</p><h3 id="2-图表对象声明"><a href="#2-图表对象声明" class="headerlink" title="2.图表对象声明"></a>2.图表对象声明</h3><p>然后是引⼊柱状图组件，完成图表对象的声明，如</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>bar = Bar()</span><br></pre></td></tr></tbody></table></figure><p>上述代码通过类Bar声明了⼀个柱状图图表组件的实例对象：bar。</p><h3 id="3-图表对象参数设置"><a href="#3-图表对象参数设置" class="headerlink" title="3.图表对象参数设置"></a>3.图表对象参数设置</h3><p>完成对象的声明以后，接下来需要进⾏参数配置，具体的代码如下所示</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#参数设置：x轴数据</span></span><br><span class="line"><span class="number">2.</span>bar.add_xaxis([<span class="string">"衬衫"</span>,<span class="string">"⽺⽑衫"</span>,<span class="string">"雪纺衫"</span>,<span class="string">"裤⼦"</span>,<span class="string">"⾼跟鞋"</span>,<span class="string">"袜⼦"</span>])</span><br><span class="line"><span class="number">3.</span><span class="comment">#参数设置：y轴数据</span></span><br><span class="line"><span class="number">4.</span>bar.add_yaxis(<span class="string">"商家A"</span>, [<span class="number">5</span>,<span class="number">20</span>,<span class="number">36</span>,<span class="number">10</span>,<span class="number">75</span>,<span class="number">90</span>])</span><br></pre></td></tr></tbody></table></figure><p>上述代码分别设置了柱状图图表对象的x轴数据和y轴数据</p><h3 id="4-图表对象渲染"><a href="#4-图表对象渲染" class="headerlink" title="4.图表对象渲染"></a>4.图表对象渲染</h3><p>参数设置完成以后，就是最后⼀步：图表对象渲染。图表对象的渲染只需要⼀⾏代码，具体的代码如</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">#图表渲染：默认⽂件命：render.html,默认路径：当前⽬录</span></span><br><span class="line"><span class="number">2.</span>bar.render()</span><br></pre></td></tr></tbody></table></figure><p>PyEcharts图表组件的渲染，在不添加任何参数的情况下，默认会在Python程序⽂件当前⽬录下，⽣成⼀个名为：render.html的HTML⻚⾯⽂件。</p><h1 id="第六节-PyEcharts开发快速入门"><a href="#第六节-PyEcharts开发快速入门" class="headerlink" title="第六节 PyEcharts开发快速入门"></a>第六节 PyEcharts开发快速入门</h1><p>PyEcharts⽀持的图表类型有30多种，具体的图表数量和版本相关</p><h2 id="PyEcharts基本图表"><a href="#PyEcharts基本图表" class="headerlink" title="PyEcharts基本图表"></a>PyEcharts基本图表</h2><p><img src="https://i.loli.net/2020/11/13/xBK3LuznWXhUjtP.png" alt="PyEcharts基本图表.png"></p><h2 id="PyEcharts配置-1"><a href="#PyEcharts配置-1" class="headerlink" title="PyEcharts配置"></a>PyEcharts配置</h2><p>PyEcharts配置项分全局配置项和系列配置项，其中全局配置项作⽤域为整个图表（与具体需要呈现的数据内容⽆关），可以理解为静态部分；系列配置项作⽤范围为基于数据动态绘制的部分。<br>全局配置项<br><img src="https://i.loli.net/2020/11/13/4a2QKuzdF7iGVsO.png" alt="PyEcharts全局配置项.png"></p><h3 id="1-初始化配置项"><a href="#1-初始化配置项" class="headerlink" title="1.初始化配置项"></a>1.初始化配置项</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">from</span>&nbsp;pyecharts&nbsp;<span class="keyword">import</span>&nbsp;options&nbsp;<span class="keyword">as</span>&nbsp;opts</span><br><span class="line"><span class="number">2.</span><span class="keyword">from</span>&nbsp;pyecharts.charts&nbsp;<span class="keyword">import</span>&nbsp;Bar</span><br><span class="line"><span class="number">3.</span><span class="keyword">from</span>&nbsp;pyecharts.faker&nbsp;<span class="keyword">import</span>&nbsp;Faker</span><br><span class="line"><span class="number">4.</span><span class="keyword">from</span>&nbsp;pyecharts.<span class="built_in">globals</span>&nbsp;<span class="keyword">import</span>&nbsp;ThemeType</span><br><span class="line"><span class="number">5.</span>c&nbsp;=&nbsp;(</span><br><span class="line"><span class="number">6.</span>&nbsp;&nbsp;&nbsp;&nbsp;Bar(init_opts=opts.InitOpts(theme=ThemeType.LIGHT,</span><br><span class="line"><span class="number">7.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width=<span class="string">"1024px"</span>,</span><br><span class="line"><span class="number">8.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height=<span class="string">"600px"</span>,</span><br><span class="line"><span class="number">9.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bg_color=<span class="string">"#d9d6c3"</span></span><br><span class="line"><span class="number">10.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))</span><br><span class="line"><span class="number">11.</span>&nbsp;&nbsp;&nbsp;&nbsp;.add_xaxis(Faker.choose())</span><br><span class="line"><span class="number">12.</span>&nbsp;&nbsp;&nbsp;&nbsp;.add_yaxis(<span class="string">"商家A"</span>,&nbsp;Faker.values())</span><br><span class="line"><span class="number">13.</span>&nbsp;&nbsp;&nbsp;&nbsp;.add_yaxis(<span class="string">"商家B"</span>,&nbsp;Faker.values())</span><br><span class="line"><span class="number">14.</span>&nbsp;&nbsp;&nbsp;&nbsp;.render(<span class="string">"demo_bar_01.html"</span>)</span><br><span class="line"><span class="number">15.</span>)</span><br></pre></td></tr></tbody></table></figure><p>通过opts.InitOpts类声明了⼀个初始化配置项对象init_opts，初始化配置项参数按照key = value的⽅式，进⾏了赋值操作。其中：theme代表主题样式，可选的范围我会在本课后⾯的“主题样式”⼩节进⾏详细介绍；width和height分别代表图表对象在⽹⻚中的宽度和⾼度；bg_color代表图表背景颜⾊，具体的⾊值，可以根据⾃⼰的需要选择。</p><h3 id="2-标题配置项"><a href="#2-标题配置项" class="headerlink" title="2.标题配置项"></a>2.标题配置项</h3><p>负责配置图表对象的标题内容，包括主标题⽂本、主标题链接、主标题链接打开⽅式；副标题⽂本、副标题链接、副标题链接打开⽅式；标题元素的位置和边距等。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">from</span>&nbsp;pyecharts&nbsp;<span class="keyword">import</span>&nbsp;options&nbsp;<span class="keyword">as</span>&nbsp;opts</span><br><span class="line"><span class="number">2.</span><span class="keyword">from</span>&nbsp;pyecharts.charts&nbsp;<span class="keyword">import</span>&nbsp;Bar</span><br><span class="line"><span class="number">3.</span><span class="keyword">from</span>&nbsp;pyecharts.faker&nbsp;<span class="keyword">import</span>&nbsp;Faker</span><br><span class="line"><span class="number">4.</span>c&nbsp;=&nbsp;(</span><br><span class="line"><span class="number">5.</span>&nbsp;&nbsp;&nbsp;&nbsp;Bar()</span><br><span class="line"><span class="number">6.</span>&nbsp;&nbsp;&nbsp;&nbsp;.add_xaxis(Faker.choose())</span><br><span class="line"><span class="number">7.</span>&nbsp;&nbsp;&nbsp;&nbsp;.add_yaxis(<span class="string">"商家A"</span>,&nbsp;Faker.values())</span><br><span class="line"><span class="number">8.</span>&nbsp;&nbsp;&nbsp;&nbsp;.add_yaxis(<span class="string">"商家B"</span>,&nbsp;Faker.values())</span><br><span class="line"><span class="number">9.</span>&nbsp;&nbsp;&nbsp;&nbsp;.set_global_opts(</span><br><span class="line"><span class="number">10.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title_opts=opts.TitleOpts(title=<span class="string">"图表标题"</span>,</span><br><span class="line"><span class="number">11.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title_link=<span class="string">"www.baidu.com"</span>,</span><br><span class="line"><span class="number">12.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title_target=<span class="string">"blank"</span>,</span><br><span class="line"><span class="number">13.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtitle=<span class="string">"图表副标题"</span>,</span><br><span class="line"><span class="number">14.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtitle_link=<span class="string">"www.baidu.com"</span>,</span><br><span class="line"><span class="number">15.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtitle_target=<span class="string">"blank"</span>,</span><br><span class="line"><span class="number">16.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos_left=<span class="string">"left"</span>,</span><br><span class="line"><span class="number">17.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;pos_right="",</span></span><br><span class="line"><span class="number">18.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;pos_bottom="40",</span></span><br><span class="line"><span class="number">19.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding=[<span class="number">5</span>,&nbsp;<span class="number">10</span>,&nbsp;<span class="number">5</span>,&nbsp;<span class="number">10</span>])&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;上右下左</span></span><br><span class="line"><span class="number">20.</span>&nbsp;&nbsp;&nbsp;&nbsp;)</span><br><span class="line"><span class="number">21.</span>&nbsp;&nbsp;&nbsp;&nbsp;.render(<span class="string">"demo_bar_02.html"</span>)</span><br><span class="line"><span class="number">22.</span>)</span><br></pre></td></tr></tbody></table></figure><p>通过opt.TitleOptions⽅法声明了⼀个标题配置项对象，标题配置项参数按照Key = value的⽅式，进⾏了赋值操作。其中：title、title_url、title_target定义了主标题⽂本、主标题链接、主标题打开⽅式；subtitle、subtitle_url、subtitle_target定义了副标题⽂本、副标题链接和副标题打开⽅式，其他参数可以参照官⽅提供的⽤户⼿册关于标题配置项的参数进⾏设定。</p><h2 id="PyEcharts图表渲染"><a href="#PyEcharts图表渲染" class="headerlink" title="PyEcharts图表渲染"></a>PyEcharts图表渲染</h2><p>PyEcharts图表渲染⽀持两种模式：<br>1.HTML⻚⾯模式和图⽚⽂件模式。默认情况下，PyEcharts图表渲染，是在当前⽂件夹下，⽣成⼀个名称为：render.html的HTML⽂件<br>2.渲染为图⽚的时候需要额外的第三⽅程序包⽀持，包名：selenium，可以通过执⾏：pip install selenium执⾏安装。渲染为图⽚的时候，需要⽤的函数为：make_snapshot</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">from</span>&nbsp;pyecharts.charts&nbsp;<span class="keyword">import</span>&nbsp;Bar</span><br><span class="line"><span class="number">2.</span><span class="comment">#&nbsp;导出图⽚，需要引⼊以下对象</span></span><br><span class="line"><span class="number">3.</span><span class="keyword">from</span>&nbsp;pyecharts.render&nbsp;<span class="keyword">import</span>&nbsp;make_snapshot</span><br><span class="line"><span class="number">4.</span><span class="keyword">from</span>&nbsp;snapshot_selenium&nbsp;<span class="keyword">import</span>&nbsp;snapshot</span><br><span class="line"><span class="number">5.</span>bar&nbsp;=&nbsp;Bar()</span><br><span class="line"><span class="number">6.</span>bar.add_xaxis([<span class="string">"衬衫"</span>,&nbsp;<span class="string">"⽺⽑衫"</span>,&nbsp;<span class="string">"雪纺衫"</span>,&nbsp;<span class="string">"裤⼦"</span>,&nbsp;<span class="string">"⾼跟鞋"</span>,&nbsp;<span class="string">"袜⼦"</span>])</span><br><span class="line"><span class="number">7.</span>bar.add_yaxis(<span class="string">"商家A"</span>,&nbsp;[<span class="number">5</span>,&nbsp;<span class="number">20</span>,&nbsp;<span class="number">36</span>,&nbsp;<span class="number">10</span>,&nbsp;<span class="number">75</span>,&nbsp;<span class="number">90</span>])</span><br><span class="line"><span class="number">8.</span><span class="comment">#&nbsp;render&nbsp;会⽣成本地&nbsp;HTML&nbsp;⽂件，默认会在当前⽬录⽣成&nbsp;render.html&nbsp;⽂件</span></span><br><span class="line"><span class="number">9.</span><span class="comment">#&nbsp;也可以传⼊路径参数，如&nbsp;bar.render("mycharts.html")</span></span><br><span class="line"><span class="number">10.</span><span class="comment">#&nbsp;默认模式</span></span><br><span class="line"><span class="number">11.</span>bar.render()</span><br><span class="line"><span class="number">12.</span><span class="comment">#&nbsp;指定路径</span></span><br><span class="line"><span class="number">13.</span>bar.render(<span class="string">"mycharts.html"</span>) <span class="comment">#第一种方法</span></span><br><span class="line"><span class="number">14.</span><span class="comment">#&nbsp;渲染成图⽚</span></span><br><span class="line"><span class="number">15.</span>make_snapshot(snapshot,&nbsp;bar.render(),&nbsp;<span class="string">"bar0.png"</span>)&nbsp; <span class="comment">#第二种方法</span></span><br></pre></td></tr></tbody></table></figure><h2 id="PyEcharts主题样式"><a href="#PyEcharts主题样式" class="headerlink" title="PyEcharts主题样式"></a>PyEcharts主题样式</h2><p>主题样式可以根据⾃⼰的业务场景和个⼈偏好选择，但要遵循⼀个基本的原则：美观⼤⽅、颜⾊鲜明、对⽐清晰。</p><h1 id="第七节-实时监控数据指标卡"><a href="#第七节-实时监控数据指标卡" class="headerlink" title="第七节 实时监控数据指标卡"></a>第七节 实时监控数据指标卡</h1><p>数据指标卡多⽤于业务实时监控，⽤来呈现核⼼的业务指标，通过呈现实时的指标值，结合指标的同⽐和环⽐变化情况，判断该指标的是否处于正常的波动范围之内。很多时候，我们不⽌需要了解当前的值和同环⽐变化情况，还要快速跳转到该指标的历史变化趋势上。<br><img src="https://i.loli.net/2020/11/13/8hMRDlbB1IE7cSJ.png" alt="数据可视化分析操作流程.png"></p><h2 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h2><p>需要从业务流程、业务规则、业务活动和总线矩阵这4个⽅⾯梳理</p><h2 id="定义指标"><a href="#定义指标" class="headerlink" title="定义指标"></a>定义指标</h2><p>实时数据监控需要监控的是核⼼业务指标</p><h2 id="定义维度"><a href="#定义维度" class="headerlink" title="定义维度"></a>定义维度</h2><p>除了核⼼指标的实时数值之外，通常需要结合指标的同⽐、环⽐、时间进度和任务⽬标完成状态等因素。因此，实时数据监控该指标卡，需要考虑的分析维度主要是时间维度和对⽐维度。</p><h2 id="设计呈现"><a href="#设计呈现" class="headerlink" title="设计呈现"></a>设计呈现</h2><p>数据指标卡的设计，需要考虑⻚⾯布局、卡⽚设计、主题样式，尤其是字体、字号和颜⾊的设计。通常情况下，数据指标卡，位于数据仪表盘的顶部，横向并⾏排列，超出部分另起⼀⾏。<br><img src="https://i.loli.net/2020/11/13/JQxmaDn84GTWsVY.png" alt="指标卡设计呈现.png"></p><h2 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h2><h3 id="1-数据理解"><a href="#1-数据理解" class="headerlink" title="1.数据理解"></a>1.数据理解</h3><h3 id="2-数据准备（数据库逻辑、数据表查找）"><a href="#2-数据准备（数据库逻辑、数据表查找）" class="headerlink" title="2.数据准备（数据库逻辑、数据表查找）"></a>2.数据准备（数据库逻辑、数据表查找）</h3><h3 id="3-图表设计"><a href="#3-图表设计" class="headerlink" title="3.图表设计"></a>3.图表设计</h3><p>图表设计包括前端模板设计和后台服务程序设计两部分，前端模板设计完成组件库的导⼊、xxx元素占位符声明和图表元素渲染，后台服务程序完成路由设计、业务逻辑和数据逻辑设计。<br>前端模板设计：<br>数据指标卡的程序设计，包括引⼊Bootstrap4框架、声明指标卡对象和配置指标卡参数。<br>后台设计：<br>接⼝设计：定义了前端的⻚⾯的调度请求地址。具体结合框架Flask，数据指标卡的程序设计后台部分，需要使⽤到 Flask 框架 。<br>路由设计：提供了服务器端的业务逻辑和访问接⼝的映射关系。具体结合框架Flask<br>业务逻辑：定义了前端请求的响应逻辑。负责响应⽤户实时指标的查询请求，调⽤数据逻辑程序，基于<br>数据逻辑查询的结果，业务逻辑程序组装出实时指标数据并返回给前端⻚⾯。<br>数据逻辑：执⾏数据库表的查询操作。负责从数据准备环节⽣成的数据⽇报中查询交易量、交易额和库存量指标，并返回给调⽤程序。</p><h3 id="4-数据验证"><a href="#4-数据验证" class="headerlink" title="4.数据验证"></a>4.数据验证</h3><p>通常的数据验证策略是：⾸先判定指标是否符合业务预期，其次判定趋势是否合理，最后判定组成结构和分布是否合理。</p><h2 id="数据发布"><a href="#数据发布" class="headerlink" title="数据发布"></a>数据发布</h2><p>实时数据监控指标卡，通常作为Dashboard⻚⾯的最突出的⼀部分，通常以⽹⻚的形式呈现。</p><h2 id="分析洞察"><a href="#分析洞察" class="headerlink" title="分析洞察"></a>分析洞察</h2><h1 id="第八节-趋势变化分析可视化"><a href="#第八节-趋势变化分析可视化" class="headerlink" title="第八节 趋势变化分析可视化"></a>第八节 趋势变化分析可视化</h1><p>实时监控数据指标卡⽤于呈现业务和发现业务问题，⼀旦发现指标异常，就需要引⼊多个不同的维度，对问题进⾏分析和判断。时间维度，即该指标的历史趋势，是要⾸先考虑的。<br>历史趋势分析问题的价值在于：⼀⽅⾯，进⼀步判断该异常是否在合理的范围之内；另外⼀⽅⾯，判断该异常是否具有周期性的特征。同时，历史数据变化趋势图，也可以⽤于发展趋势预测。</p><p>通过数据可视化的⽅式，呈现业务指标的历史变化趋势；通过业务指标曲线的平滑程度和总体变化趋势，呈现该指标是否异常和指标的总体变化趋势。 历史数据变化趋势图的价值在于，对历史业务状态的呈现，以及基于历史状态趋势判断当前实时数据是否符合预期，基于线性回归预测下⼀个阶段的指标变化等<br>通常采用：<br>折线图<br>面积图</p><h2 id="业务理解-1"><a href="#业务理解-1" class="headerlink" title="业务理解"></a>业务理解</h2><h2 id="定义指标-1"><a href="#定义指标-1" class="headerlink" title="定义指标"></a>定义指标</h2><p>历史数据变化趋势图，可以⽤来呈现任何需要的、具有时间序列特征的指标。具体的指标可以基于业务需求选择。</p><h2 id="定义维度-1"><a href="#定义维度-1" class="headerlink" title="定义维度"></a>定义维度</h2><p>历史数据变化趋势的核⼼是：呈现指标随时间变化的趋势。</p><h2 id="设计呈现-1"><a href="#设计呈现-1" class="headerlink" title="设计呈现"></a>设计呈现</h2><p>历史数据变化趋势图，位于数据仪表盘数据指标卡的下⽅，单图成⾏或者横向并⾏排列，超出的部分另起⼀⾏。<br><img src="https://i.loli.net/2020/11/13/IJjlkK28brNoc3h.png" alt="趋势图设计呈现.png"></p><h2 id="程序开发-1"><a href="#程序开发-1" class="headerlink" title="程序开发"></a>程序开发</h2><h3 id="1-数据理解-1"><a href="#1-数据理解-1" class="headerlink" title="1.数据理解"></a>1.数据理解</h3><h3 id="2-数据准备"><a href="#2-数据准备" class="headerlink" title="2.数据准备"></a>2.数据准备</h3><h3 id="3-图标设计"><a href="#3-图标设计" class="headerlink" title="3.图标设计"></a>3.图标设计</h3><p>本节使用PyEcharts框架⽣成单⻚⾯的可视化图表。<br>图表设计包括数据查询和图表创建两个部分。数据查询实现与MySQL数据库建⽴连接、读取数据和格式化输出（Pymysql.cursors）；图表创建包括⽂件导⼊、对象声明、参数配置和⻚⾯渲染。</p><p>PyEcharts图表程序设计部分需要完成4个步骤：⽂件导⼊、对象声明、参数配置和⻚⾯渲染。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#⽂件导⼊</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">from</span>&nbsp;pyecharts&nbsp;<span class="keyword">import</span>&nbsp;options&nbsp;<span class="keyword">as</span>&nbsp;opts</span><br><span class="line"><span class="number">3.</span><span class="keyword">import</span>&nbsp;pymysql.cursors</span><br><span class="line"><span class="number">4.</span><span class="keyword">from</span>&nbsp;pyecharts.charts&nbsp;<span class="keyword">import</span>&nbsp;Line</span><br><span class="line"><span class="number">5.</span><span class="comment">#&nbsp;执⾏主函数</span></span><br><span class="line"><span class="number">6.</span><span class="keyword">if</span>&nbsp;__name__&nbsp;==&nbsp;<span class="string">'__main__'</span>:</span><br><span class="line"><span class="number">7.</span>&nbsp;&nbsp;&nbsp;&nbsp;print(order_sum_query())</span><br><span class="line"><span class="number">8.</span><span class="comment">#数据查询</span></span><br><span class="line"><span class="number">9.</span>&nbsp;&nbsp;&nbsp;&nbsp;dataX,&nbsp;dataY&nbsp;=&nbsp;order_sum_query()</span><br><span class="line"><span class="number">10.</span><span class="comment">#对象声明</span></span><br><span class="line"><span class="number">11.</span>&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;=&nbsp;Line()</span><br><span class="line"><span class="number">12.</span>&nbsp;&nbsp;&nbsp;&nbsp;line.add_xaxis(dataX)</span><br><span class="line"><span class="number">13.</span>&nbsp;&nbsp;&nbsp;&nbsp;line.add_yaxis(<span class="string">"订单量"</span>,&nbsp;dataY,&nbsp;is_smooth=<span class="literal">True</span>)</span><br><span class="line"><span class="number">14.</span>&nbsp;&nbsp;&nbsp;&nbsp;line.set_global_opts(&nbsp; &nbsp; &nbsp;  <span class="comment">#参数设置</span></span><br><span class="line"><span class="number">15.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title_opts=opts.TitleOpts(title=<span class="string">"⽇订单量历史数据趋势图"</span>),</span><br><span class="line"><span class="number">16.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yaxis_opts=opts.AxisOpts(</span><br><span class="line"><span class="number">17.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type_=<span class="string">"value"</span>,</span><br><span class="line"><span class="number">18.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axistick_opts=opts.AxisTickOpts(is_show=<span class="literal">True</span>),</span><br><span class="line"><span class="number">19.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitline_opts=opts.SplitLineOpts(is_show=<span class="literal">True</span>),</span><br><span class="line"><span class="number">20.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;),</span><br><span class="line"><span class="number">21.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaxis_opts=opts.AxisOpts(type_=<span class="string">"category"</span>,&nbsp;boundary_gap=<span class="literal">False</span>)</span><br><span class="line"><span class="number">22.</span>&nbsp;&nbsp;&nbsp;&nbsp;)</span><br><span class="line"><span class="number">23.</span>&nbsp;&nbsp;&nbsp;&nbsp;line.render(&nbsp;) <span class="comment">#页面渲染</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-数据验证-1"><a href="#4-数据验证-1" class="headerlink" title="4.数据验证"></a>4.数据验证</h3><h2 id="数据发布-1"><a href="#数据发布-1" class="headerlink" title="数据发布"></a>数据发布</h2><h2 id="分析洞察-1"><a href="#分析洞察-1" class="headerlink" title="分析洞察"></a>分析洞察</h2><p>历史数据变化趋势图的分析⽅法，是通过数据可视化曲线的平滑程度和总体变化趋势进⾏判断。判断的基本逻辑是：是否有异常点出现，变化趋势是平滑向上还是平滑向下。</p><h1 id="第九节-构成分析可视化"><a href="#第九节-构成分析可视化" class="headerlink" title="第九节 构成分析可视化"></a>第九节 构成分析可视化</h1><p>指标的构成元素模型，其价值在于，从⽬标指标的构成结构上，发现各构成元素的构成⽐例，从⽽发现对⽬标指标影响最⼤的构成元素。<br>⼀个基本的商品构成图，在Echarts标准图表库中，通常采⽤基本饼状图或环形图的来呈现，也可以是二者的组合图，这样的组合不仅能展示每种商品类型的⽐例，还能更加详细地展示每⼀种商品类型的⼦类型产品的⽐例，能让你更加详细地了解商品类型的组成分布。</p><h2 id="步骤同上"><a href="#步骤同上" class="headerlink" title="步骤同上"></a>步骤同上</h2><h1 id="第十节-地理位置分布图可视化"><a href="#第十节-地理位置分布图可视化" class="headerlink" title="第十节 地理位置分布图可视化"></a>第十节 地理位置分布图可视化</h1><p>客户地址位置分布⼀⽅⾯可以评估客户营销的效果，另外⼀⽅⾯可以辅助寻找最有价值的客户地理分布，从⽽辅助决策营销策略的优化和调整。<br><img src="https://i.loli.net/2020/11/13/TfKFCjG4SeoMdsE.png" alt="地理位置分布设计呈现.png"><br>根据统计维度的层级不同，可以展示不同层级下的客户位置信息分布情况，⽐如从全球层⾯来看每个国家的客户数量、某个国家的客户数量、某个国家的某个地区的客户数量，层层对⽐下可以找出客户数量的分布在每个层级的分布情况以及差异。</p><h1 id="第十一节-柱状图可视化"><a href="#第十一节-柱状图可视化" class="headerlink" title="第十一节 柱状图可视化"></a>第十一节 柱状图可视化</h1><p>柱状图的变形和延伸表现形式图表有簇状条形图和堆积条形图等，⼆者有时也被称为：簇状图和堆积图，或者簇型柱状图和堆积柱状图。</p><h2 id="步骤同上-1"><a href="#步骤同上-1" class="headerlink" title="步骤同上"></a>步骤同上</h2><h1 id="第十二节-雷达图可视化"><a href="#第十二节-雷达图可视化" class="headerlink" title="第十二节 雷达图可视化"></a>第十二节 雷达图可视化</h1><p>雷达图，⼜称蜘蛛⽹图，通常适⽤于三个或者更多维度的变量。雷达图以在同⼀点开始的轴上显示的三个，或者更多个变量的⼆维图表的形式，来展示多元数据。</p><p>雷达图通常⽤来查看哪些变量具有相似的值、变量之间是否有异常值、变量在数据集内分布的⾼低，以及排名、评估、评论等数据的展示。</p><h2 id="步骤同上-2"><a href="#步骤同上-2" class="headerlink" title="步骤同上"></a>步骤同上</h2>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyEcharts </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python线性回归学习笔记</title>
      <link href="2020/11/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APython%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APython%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是阅读书籍《Python数据分析-活用Pandas库读书笔记》第12、13、14章节「数据建模」整理的学习笔记</em></strong></p><h2 id="线性模型-多元回归"><a href="#线性模型-多元回归" class="headerlink" title="线性模型(多元回归)"></a>线性模型(多元回归)</h2><h3 id="统计学库statsmodels"><a href="#统计学库statsmodels" class="headerlink" title="统计学库statsmodels"></a>统计学库statsmodels</h3><p>（亦可参考下面系数显著性）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line">model = smf.ols(formula=<span class="string">'y ~ x1 + x2 +x3'</span>,data=df).fit() <span class="comment">#model即为OLS回归模型,x1为column</span></span><br><span class="line">model.sumamry() <span class="comment"># 结果汇总表</span></span><br><span class="line">model.params <span class="comment"># 获得回归系数</span></span><br><span class="line">model.conf_int() <span class="comment"># 获得置信区间</span></span><br></pre></td></tr></tbody></table></figure><p>或</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">X = diabetes.data</span><br><span class="line">y = diabetes.target</span><br><span class="line"></span><br><span class="line">X2 = sm.add_constant(X)</span><br><span class="line">est = sm.OLS(y, X2)</span><br><span class="line">est2 = est.fit()</span><br><span class="line">print(est2.summary())</span><br></pre></td></tr></tbody></table></figure><h4 id="若含分类变量-虚拟变量"><a href="#若含分类变量-虚拟变量" class="headerlink" title="若含分类变量(虚拟变量)"></a>若含分类变量(虚拟变量)</h4><p>statsmodels 会自动创建虚拟变量，且删除多余参考变量来避免多重共线性，可以理解为statsmodels 在一定程度上可以减轻多重共线性<br>比如 <code>model = smf.ols(formula='y ~ x1 + x2 +x3 + day',data=df).fit() #model即为OLS回归模型</code> ,回归结果中只有<br>day[T.Fri] \ day[Sat] \ day[Sun] 比原本的 Fri\Sat\Sun\Thur 少了Thur，就说明它就是那个用于解释系数的参考变量</p><h3 id="科学库-sklearn"><a href="#科学库-sklearn" class="headerlink" title="科学库 sklearn"></a>科学库 sklearn</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">lr = linear_model.LinearRegression()</span><br><span class="line">predicted = lr.fit(X=df[<span class="string">'x1'</span>,<span class="string">'x2'</span>,<span class="string">'x3'</span>],y=df[<span class="string">'y'</span>])  <span class="comment"># predicted即为线性回归模型</span></span><br><span class="line"><span class="comment"># 注意如果自变量只有一元，则要重塑变量格式，predicted = lr.fit(X=df['x1'].values.reshape(-1,1),y=df['y'].values)</span></span><br><span class="line">predicted.coef_ <span class="comment"># 获得回归自变量系数</span></span><br><span class="line">predicted.intercept_  <span class="comment"># 获得回归截距项（常数项）</span></span><br></pre></td></tr></tbody></table></figure><h4 id="若含分类变量-虚拟变量-1"><a href="#若含分类变量-虚拟变量-1" class="headerlink" title="若含分类变量(虚拟变量)"></a>若含分类变量(虚拟变量)</h4><p>需要使用get_dummies 函数创建虚拟变量，如</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df_dummy = pd.get_dummies(df[[<span class="string">'x1'</span>,<span class="string">'sex'</span>,<span class="string">'day'</span>]])</span><br><span class="line">print(df_dummy) <span class="comment"># 会生成sex_Male \ sex_Female \day_Fri \ day_Sat \ day_Sun \ day_Thur</span></span><br><span class="line">df_dummy_ref = pd.get_dummies(df[[<span class="string">'x1'</span>,<span class="string">'sex'</span>,<span class="string">'day'</span>]],drop_first=<span class="literal">True</span>) <span class="comment"># drop_first删除虚拟变量</span></span><br><span class="line">print(df_dummy_ref)  <span class="comment"># 会自动去掉参考变量（多重共线性）生成sex_Female \ day_Fri \ day_Sat \ day_Sun</span></span><br><span class="line">lr = linear_model.LinearRegression()</span><br><span class="line">predicted = lr.fit(X=df_dummy_ref,y=df[<span class="string">'y'</span>])</span><br></pre></td></tr></tbody></table></figure><h4 id="解决sklearn回归模型不带标签的问题"><a href="#解决sklearn回归模型不带标签的问题" class="headerlink" title="解决sklearn回归模型不带标签的问题"></a>解决sklearn回归模型不带标签的问题</h4><p>sklearn模型结果不带标签（即不会给出系数是哪个自变量的系数），原因是NumPy ndarray无法存储这类元数据，因此需要手动存储标签</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">df_dummy_ref = pd.get_dummies(df[[<span class="string">'x1'</span>,<span class="string">'sex'</span>,<span class="string">'day'</span>]],drop_first=<span class="literal">True</span>)</span><br><span class="line">lr = linear_model.LinearRegression()</span><br><span class="line">predicted = lr.fit(X=df_dummy_ref,y=df[<span class="string">'y'</span>])</span><br><span class="line">values = np.append(predicted.intercept_,predicted.coef_) <span class="comment"># 获取回归系数和截距项（常数项）</span></span><br><span class="line">names = np.append(<span class="string">'intercept'</span>,df_dummy_ref.columns)  <span class="comment"># 获取值对应名称</span></span><br><span class="line">results = pd.DataFrame(values,index=names,columns=[<span class="string">'coef'</span>]) <span class="comment"># 把所有项放入一个带标签的DataFrame中</span></span><br></pre></td></tr></tbody></table></figure><h2 id="逻辑回归（广义线性模型（GLM））"><a href="#逻辑回归（广义线性模型（GLM））" class="headerlink" title="逻辑回归（广义线性模型（GLM））"></a>逻辑回归（广义线性模型（GLM））</h2><p>当相应变量(y)不是连续的时候，更适合使用GLM模型，如逻辑回归、泊松回归等，特别的，当y是二值变量时，常用逻辑回归</p><h3 id="统计学库statsmodels-1"><a href="#统计学库statsmodels-1" class="headerlink" title="统计学库statsmodels"></a>统计学库statsmodels</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line">model = smf.logit(formula=<span class="string">'y ~ x1 + x2 +x3'</span>,data=df).fit() <span class="comment">#其中，y为二值变量</span></span><br><span class="line">model.sumamry() <span class="comment"># 结果汇总表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在逻辑回归中，与所有广义线性模型一样，都需要还有连接函数执行一定的转换，如需要解释逻辑模型，则需要将结果指数化</span></span><br><span class="line">odd_ratios = np.exp(model.params) <span class="comment"># 结果应该解释为如果x1每增加一倍，则y为1的概率就会增加多少倍（指数化后的系数值）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用sklearn"><a href="#使用sklearn" class="headerlink" title="使用sklearn"></a>使用sklearn</h3><p>先手动创建虚拟变量get_dummies,再进行回归，然后把结果手动存储到标签，最后为了解释系数将值指数化</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> linear_model <span class="keyword">from</span> sklearn</span><br><span class="line">predictors = pd.get_dummies(df[[<span class="string">'x1'</span>,<span class="string">'x2'</span>,<span class="string">'x3'</span>,<span class="string">'x4'</span>]],drop_first=<span class="literal">True</span>)</span><br><span class="line">lr = linear_model.LogisticRegrssion()</span><br><span class="line">results = lr.fit(X=predictors,y=df[<span class="string">'y'</span>])</span><br><span class="line">values = np.append(predicted.intercept_,predicted.coef_) <span class="comment"># 获取回归系数和截距项（常数项）</span></span><br><span class="line">names = np.append(<span class="string">'intercept'</span>,df_dummy_ref.columns)  <span class="comment"># 获取值对应名称</span></span><br><span class="line">results = pd.DataFrame(values,index=names,columns=[<span class="string">'coef'</span>]) <span class="comment"># 把所有项放入一个带标签的DataFrame中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了解释系数将值指数化</span></span><br><span class="line">results[<span class="string">'or'</span>] = np.exp(results[<span class="string">'coef'</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="泊松回归（广义线性模型（GLM））"><a href="#泊松回归（广义线性模型（GLM））" class="headerlink" title="泊松回归（广义线性模型（GLM））"></a>泊松回归（广义线性模型（GLM））</h2><p>当响应变量y为计数数据时，常使用泊松回归，也可以使用更通用的glm函数来执行</p><h3 id="统计学库statsmodels-2"><a href="#统计学库statsmodels-2" class="headerlink" title="统计学库statsmodels"></a>统计学库statsmodels</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用poisson回归</span></span><br><span class="line">model = smf.poisson(formula=<span class="string">'y ~ x1 + x2 +x3'</span>,data=df).fit()</span><br><span class="line"><span class="comment"># 使用glm函数</span></span><br><span class="line">model = smf.glm(</span><br><span class="line">    formula=<span class="string">'y ~ x1 + x2 +x3'</span></span><br><span class="line">    ,data=df</span><br><span class="line">    ,family=sm.families.Poisson(sm.genmod.families.links.log)</span><br><span class="line">).fit()</span><br></pre></td></tr></tbody></table></figure><h2 id="模型诊断"><a href="#模型诊断" class="headerlink" title="模型诊断"></a>模型诊断</h2><h3 id="比较模型本身好坏：残差"><a href="#比较模型本身好坏：残差" class="headerlink" title="比较模型本身好坏：残差"></a>比较模型本身好坏：残差</h3><p>残差是实际观测值和模型估计值之差<br>对于statsmodels，使用model.resid_deviance 读取回归模型的残差</p><h3 id="比较模型本身好坏：Q-Q图"><a href="#比较模型本身好坏：Q-Q图" class="headerlink" title="比较模型本身好坏：Q-Q图"></a>比较模型本身好坏：Q-Q图</h3><p>Q-Q图用于判断数据是否符合某个参考分布，许多模型都假设数据符合正态分布，因此可以用Q-Q图检验数据是否来自正态分布</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line">resid = model.resid_deviance.copy() <span class="comment"># 获取回归模型的残差</span></span><br><span class="line">resid_std = stats.zscore(resid)  <span class="comment"># 标准化</span></span><br><span class="line"></span><br><span class="line">fig = statsmodes.graphics.qqplot(resid,line=<span class="string">'r'</span>) <span class="comment"># 绘制QQ图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>还可以绘制残差直方图，用于判断是否符合正态分布</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fog,ax = plt.subplots()</span><br><span class="line">ax = sns.distplot(resid_std) <span class="comment"># 绘制残差直方图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><h3 id="系数是否显著"><a href="#系数是否显著" class="headerlink" title="系数是否显著"></a>系数是否显著</h3><p>sklearn不支持查看系数的p-value，可以参考statsmodels模块。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">X = diabetes.data</span><br><span class="line">y = diabetes.target</span><br><span class="line"></span><br><span class="line">X2 = sm.add_constant(X)</span><br><span class="line">est = sm.OLS(y, X2)</span><br><span class="line">est2 = est.fit()</span><br><span class="line">print(est2.summary())</span><br></pre></td></tr></tbody></table></figure><h3 id="比较模型之间好坏"><a href="#比较模型之间好坏" class="headerlink" title="比较模型之间好坏"></a>比较模型之间好坏</h3><h4 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h4><blockquote><p>方差分析会给出残差平方和RSS，残差平方和越小，模型拟合效果越好<br>AIC和BIC<br>（详见书第14章）</p></blockquote><h4 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h4><blockquote><p>方差分析<br>AIC和BIC</p></blockquote><h4 id="还可以使用K折交叉验证评判模型好坏"><a href="#还可以使用K折交叉验证评判模型好坏" class="headerlink" title="还可以使用K折交叉验证评判模型好坏"></a>还可以使用K折交叉验证评判模型好坏</h4><p>这种方法将数据分成K个部分，把其中一格部分用作测试集，其余部分用作训练集以拟合模型。<br>模型拟合好之后，使用测试集进行测试，并计算误差。不断重复这个过程，直到K个部分都测试过。<br>模型最终的误差是所有模型的平均值。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeautifulSoup学习笔记</title>
      <link href="2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ABeautifulSoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ABeautifulSoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是学习Beautiful Soup官方教程后整理的学习笔记<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/</a></em></strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的 Python 库.它能够通过你喜欢的解析器实现文档导航,查找,修改文档.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用 request 向服务器请求网页</span></span><br><span class="line">wb_data = requests.get(<span class="string">"http://www.baidu.com"</span>)    <span class="comment"># 获得完整的 HTTP response</span></span><br><span class="line"><span class="comment">#使用 beautifulsoup 解析网页</span></span><br><span class="line">soup = Beautifulsoup(wb_data.text,<span class="string">'lxml'</span>)   <span class="comment"># 用`.text`提取HTTP体，即HTML文档,指定解析器html.parser，不指定也可以，python会调用最合适的解析器</span></span><br></pre></td></tr></tbody></table></figure><p>BeautifulSoup(wb_data.text, “html.parser”)这里的第二个参数表示使用的解析器，BeautifulSoup提供了三个解析器，它们各自的优缺点如下</p><ol><li>html.parser内置不依赖扩展，容错能力强，速度适中</li><li>lxml速度最快，容错能力强，但是依赖C扩展</li><li>html5hib速度最慢，容错能力最强，依赖扩展</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = '''<span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">'list1'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1第1项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1第2项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'first'</span>&gt;</span>文字1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'second'</span>&gt;</span>文字2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">'list2'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2第1项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2第2项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>'''</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(a, <span class="string">"html.parser"</span>)</span><br><span class="line">soup.title.text <span class="comment"># '标题'只需要使用title标签名来识别，因为只出现过一次title标签</span></span><br><span class="line">soup.find(<span class="string">'p'</span>, attrs={<span class="string">'class'</span>:<span class="string">'first'</span>}).text <span class="comment"># '文字1'不能只使用p标签，因为“文字2”也对应了p标签，所以要用p标签且class属性是'second'来识别</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>) <span class="comment"># 如果“文字1”和“文字2”都要，就可以循环获取所有p标签提取内容,再分别从中提取文字</span></span><br><span class="line">soup.find(<span class="string">'ul'</span>, attrs={<span class="string">'class'</span>:<span class="string">'list1'</span>}).find_all(<span class="string">'li'</span>) <span class="comment"># 如果想提取列表1中的两项，就不能直接循环获取li标签了，因为列表2中也有li标签。此时需要先识别其父节点，先定位到&lt;ul class='list1'&gt;这个标签上（通过ul标签和class属性是list1定位）</span></span><br></pre></td></tr></tbody></table></figure><p>其实到最后会发现这个库唯一一个要重点掌握的方法是find_all</p><h2 id="识别标签"><a href="#识别标签" class="headerlink" title="识别标签"></a>识别标签</h2><h3 id="只根据标签识别"><a href="#只根据标签识别" class="headerlink" title="只根据标签识别"></a>只根据标签识别</h3><ol><li>找到名为a的标签（查找唯一标签）</li><li>找到所有名为a的标签</li><li>找到名为a或b的标签</li><li>根据正则表达式提取标签</li></ol><p>对象的属性调用，直接提取该名字的标签，但是如果有很多该标签只能找到第一个<br>find方法，也只能找到第一个<br>find_all方法，找到所有该标签，返回一个list，如果只找到一个也是返回list，用[0]提取</p><p>比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = '''</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将提取到的字符串转化为beautifulsoup的对象</span></span><br><span class="line">soup = BeautifulSoup(a, <span class="string">"html.parser"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取唯一标签</span></span><br><span class="line">soup.h1</span><br><span class="line">soup.find(<span class="string">'h1'</span>)</span><br><span class="line">soup.find_all(<span class="string">'h1'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#上面三条结果都是&lt;h1&gt;标题1&lt;/h1&gt;</span></span><br><span class="line"></span><br><span class="line">soup.find_all(<span class="string">'h2'</span>) <span class="comment"># [&lt;h2&gt;标题2&lt;/h2&gt;, &lt;h2&gt;标题3&lt;/h2&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.find_all([<span class="string">'h1'</span>,<span class="string">'h2'</span>]) <span class="comment"># [&lt;h1&gt;标题1&lt;/h1&gt;, &lt;h2&gt;标题2&lt;/h2&gt;, &lt;h2&gt;标题3&lt;/h2&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">soup.find_all(re.<span class="built_in">compile</span>(<span class="string">'^h'</span>))  <span class="comment"># [&lt;h1&gt;标题1&lt;/h1&gt;, &lt;h2&gt;标题2&lt;/h2&gt;, &lt;h2&gt;标题3&lt;/h2&gt;]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="根据标签和属性识别"><a href="#根据标签和属性识别" class="headerlink" title="根据标签和属性识别"></a>根据标签和属性识别</h3><p>要参考属性提取标签时，只有find和find_all两种方法，find总是返回找到的第一个，而find_all会返回所有，如果想要第一个就提取即可，因此这里全用find_all来讲，其实只是加一个attrs参数</p><p>比如</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = '''</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">'p1'</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">'p2'</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'p3'</span>&gt;</span>段落3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'p3'</span> <span class="attr">id</span>=<span class="string">'pp'</span>&gt;</span>段落4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(a, <span class="string">"html.parser"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种，直接将属性名作为参数名，但是有些属性不行，比如像a-b这样的属性</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, <span class="built_in">id</span> = <span class="string">'p1'</span>) <span class="comment"># 一般情况</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, class_=<span class="string">'p3'</span>) <span class="comment"># class是保留字比较特殊，需要后面加一个_</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最通用的方法</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, attrs={<span class="string">'class'</span>:<span class="string">'p3'</span>}) <span class="comment"># 包含这个属性就算，而不是只有这个属性</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, attrs={<span class="string">'class'</span>:<span class="string">'p3'</span>,<span class="string">'id'</span>:<span class="string">'pp'</span>}) <span class="comment"># 使用多个属性匹配</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, attrs={<span class="string">'class'</span>:<span class="string">'p3'</span>,<span class="string">'id'</span>:<span class="literal">False</span>}) <span class="comment"># 指定不能有某个属性</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, attrs={<span class="string">'id'</span>:[<span class="string">'p1'</span>,<span class="string">'p2'</span>]}) <span class="comment"># 属性值是p1或p2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式匹配</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">soup.find_all(<span class="string">'p'</span>, attrs={<span class="string">'id'</span>:re.<span class="built_in">compile</span>(<span class="string">'^p'</span>)}) <span class="comment"># 使用正则表达式</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, attrs={<span class="string">'class'</span>:<span class="literal">True</span>}) <span class="comment"># 含有class属性即可</span></span><br></pre></td></tr></tbody></table></figure><h3 id="根据标签内的内容来识别"><a href="#根据标签内的内容来识别" class="headerlink" title="根据标签内的内容来识别"></a>根据标签内的内容来识别</h3><p>这部分还是使用find_all函数，增加text参</p><p>比如</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = '''</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">'p1'</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'p3'</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'p3'</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(a, <span class="string">"html.parser"</span>)</span><br><span class="line"></span><br><span class="line">soup.find_all(<span class="string">'p'</span>, text=<span class="string">'文章'</span>)</span><br><span class="line">soup.find_all(<span class="string">'p'</span>, text=[<span class="string">'段落1'</span>,<span class="string">'段落2'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">soup.find_all(<span class="string">'p'</span>, text=re.<span class="built_in">compile</span>(<span class="string">'段落'</span>))</span><br><span class="line">soup.find_all(<span class="string">'p'</span>,text=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> c <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'段落1'</span>,<span class="string">'段落2'</span>,<span class="string">'文章'</span>]</span><br><span class="line">soup.find_all(<span class="string">'p'</span>,text=nothing)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span>(<span class="params">c</span>):</span>  </span><br><span class="line">    <span class="keyword">return</span> c <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">soup.find_all(<span class="string">'p'</span>,text=nothing)</span><br></pre></td></tr></tbody></table></figure><h3 id="根据位置识别"><a href="#根据位置识别" class="headerlink" title="根据位置识别"></a>根据位置识别</h3><p>找到 第i个a标签<br>找到 第i个和第j个a标签</p><p>有时三个标签的标签属性全都一样，所有东西都一样（内容可能不一样，但是类型是一样的），但是我们只想要第二个，这时就不能只通过标签属性内容这些方法提取了，可能它的位置是特殊的就可以用位置来提取。这里其实可以用find_all提取出列表，然后在列表中根据位置再提取一次</p><h2 id="提取内容"><a href="#提取内容" class="headerlink" title="提取内容"></a>提取内容</h2><h3 id="提取标签内容使用-text"><a href="#提取标签内容使用-text" class="headerlink" title="提取标签内容使用.text"></a>提取标签内容使用.text</h3><h3 id="提取标签属性值，像字典一样提取"><a href="#提取标签属性值，像字典一样提取" class="headerlink" title="提取标签属性值，像字典一样提取"></a>提取标签属性值，像字典一样提取</h3><p>比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = '''</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'www.biaoti.com'</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(a, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取内容</span></span><br><span class="line">soup.p.text</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> soup.find_all(<span class="string">'p'</span>):</span><br><span class="line">    print(p.text)</span><br><span class="line">soup.h.text <span class="comment"># 多层嵌套也可以直接返回</span></span><br><span class="line">soup.h.a.text <span class="comment"># 也可以这样</span></span><br><span class="line">soup.body.text <span class="comment"># 里面有多个内容时 '\n标题\n段落1\n段落2\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取属性值，像字典一样提取，以下两种方法等价</span></span><br><span class="line">soup.h.a[<span class="string">'href'</span>]</span><br><span class="line">soup.h.a.get(<span class="string">'href'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="其他提取细节"><a href="#其他提取细节" class="headerlink" title="其他提取细节"></a>其他提取细节</h2><p>多层嵌套标签时的find_all——渗透到所有层次子节点全部提取出来<br>find_all的简写方法——可以省去find_all这8个字母<br>find_all的其他参数<br>通过css选择器来提取<br>库中的其他函数</p><p>比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = '''</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">'s'</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(a, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多层嵌套标签</span></span><br><span class="line">soup.find_all(<span class="string">'span'</span>) <span class="comment"># 3个元素</span></span><br><span class="line">    <span class="comment"># [&lt;span&gt;</span></span><br><span class="line">    <span class="comment">#  &lt;span&gt;内容1&lt;/span&gt;</span></span><br><span class="line">    <span class="comment">#  &lt;/span&gt;, &lt;span&gt;内容1&lt;/span&gt;, &lt;span&gt;内容2&lt;/span&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find_all的简写，标签直接加括号</span></span><br><span class="line">soup.span(<span class="string">'span'</span>,<span class="built_in">id</span>=<span class="string">'s'</span>) <span class="comment"># 相当于调用find_all返回list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find_all的其他参数</span></span><br><span class="line">soup.find_all(<span class="string">'span'</span>, limit=<span class="number">2</span>) <span class="comment"># 限制只返回前两个</span></span><br><span class="line">soup.find_all(<span class="string">'span'</span>, recursive=<span class="literal">False</span>) <span class="comment"># 只查找子节点，不查找孙节点</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BeautifulSoup </tag>
            
            <tag> Requests </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精益数据分析读书笔记</title>
      <link href="2020/10/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B2%BE%E7%9B%8A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>2020/10/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B2%BE%E7%9B%8A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong><em>精益数据分析<br>[加] 阿利斯泰尔·克罗尔、[加] 本杰明·尤科维奇 / 韩知白、王鹤达 / 人民邮电出版社 / 2014-12<br>豆瓣链接<a href="https://book.douban.com/subject/26278639/">https://book.douban.com/subject/26278639/</a></em></strong></p><h1 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h1><blockquote><p>认真看了前21章，第三部分后内容多是前面观点思路的重复，更精准的读者是创业者。<br>书中提出了很多不错的数据分析的思路、框架、关键指标，也适合相关从业人员阅读，作为理论性的书籍总体值得推荐。如果时间有限或觉得枯燥的话，重点看看前7章就足够了，精华都在开头章节。</p></blockquote><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h2 id="最小可行化产品"><a href="#最小可行化产品" class="headerlink" title="最小可行化产品"></a>最小可行化产品</h2><p>Airbnb最初产品表明附有专业摄影师的房源可获得更多的订单数量</p><h2 id="好的数据指标"><a href="#好的数据指标" class="headerlink" title="好的数据指标"></a>好的数据指标</h2><blockquote><p>可比的<br>简单易懂的<br>是个比率</p></blockquote><h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><ol><li>定性与定量</li><li>虚荣指标和可付诸行动的指标<br>比如总注册用户数就是虚荣型指标</li><li>探索性指标和报告性指标<br>“妈妈圈”的成功——在一个更小的、更容易触及的目标市场中培养更多具有黏性的高活跃用户</li><li>先见性指标和后见性指标</li><li>相关性和指标和因果性指标</li></ol><h2 id="测试用户群体分类的方法"><a href="#测试用户群体分类的方法" class="headerlink" title="测试用户群体分类的方法"></a>测试用户群体分类的方法</h2><ol><li>市场细分</li><li>同期群分析</li><li>A/B测试</li><li>多变量分析</li></ol><h2 id="可付诸行动的商业计划书"><a href="#可付诸行动的商业计划书" class="headerlink" title="可付诸行动的商业计划书"></a>可付诸行动的商业计划书</h2><ol><li>问题</li><li>客户群体分类</li><li>独特卖点</li><li>解决方案</li><li>渠道:如何将产品送到客户中</li><li>收入分析</li><li>成本分析</li><li>关键指标</li><li>门槛优势</li></ol><h2 id="数据分析的模型"><a href="#数据分析的模型" class="headerlink" title="数据分析的模型"></a>数据分析的模型</h2><h3 id="AARRR指标"><a href="#AARRR指标" class="headerlink" title="AARRR指标"></a>AARRR指标</h3><blockquote><p>获取、活跃、留存、转化、推荐<br>侧重获取或转化用户的行为</p></blockquote><h3 id="增长引擎：在何时以何种方式增长"><a href="#增长引擎：在何时以何种方式增长" class="headerlink" title="增长引擎：在何时以何种方式增长"></a>增长引擎：在何时以何种方式增长</h3><blockquote><p>黏着式增长<br>病毒式增长<br>付费式增长</p></blockquote><h3 id="可付诸行动的商业计划书-1"><a href="#可付诸行动的商业计划书-1" class="headerlink" title="可付诸行动的商业计划书"></a>可付诸行动的商业计划书</h3><p>厘清商业模式以及组成部分</p><h3 id="增长金字塔"><a href="#增长金字塔" class="headerlink" title="增长金字塔"></a>增长金字塔</h3><p>在何时以何种方式增长</p><h3 id="漏斗模型"><a href="#漏斗模型" class="headerlink" title="漏斗模型"></a>漏斗模型</h3><p>侧重获取或转化用户的行为</p><h2 id="北极星指标"><a href="#北极星指标" class="headerlink" title="北极星指标"></a>北极星指标</h2><p>数据是是假设检验的极佳工具，除非结合人类的反思，否则很难在产生新假设方面有建树</p><p>简单、即时、可行动的、可比较的、根本性</p><h2 id="互联网商业模式"><a href="#互联网商业模式" class="headerlink" title="互联网商业模式"></a>互联网商业模式</h2><h3 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h3><h4 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h4><p>用户获取模式<br>混合模式<br>忠诚度模式</p><h3 id="SaaS付费订阅软件"><a href="#SaaS付费订阅软件" class="headerlink" title="SaaS付费订阅软件"></a>SaaS付费订阅软件</h3><p>求职软件将月费转为单次时间付费</p><h3 id="免费移动应用"><a href="#免费移动应用" class="headerlink" title="免费移动应用"></a>免费移动应用</h3><p>北极星指标是平均每位用户营收</p><h3 id="媒体网站"><a href="#媒体网站" class="headerlink" title="媒体网站"></a>媒体网站</h3><p>北极星指标是网站库存</p><h3 id="用户生成内容"><a href="#用户生成内容" class="headerlink" title="用户生成内容"></a>用户生成内容</h3><p>北极星指标是访客访问度、用户生成与互动</p><blockquote><p>参与度漏斗</p></blockquote><h3 id="双边市场"><a href="#双边市场" class="headerlink" title="双边市场"></a>双边市场</h3><p>新增节点</p><h2 id="创业各阶段的划分"><a href="#创业各阶段的划分" class="headerlink" title="创业各阶段的划分"></a>创业各阶段的划分</h2><h3 id="移情：发现商机、发现值得解决的问题"><a href="#移情：发现商机、发现值得解决的问题" class="headerlink" title="移情：发现商机、发现值得解决的问题"></a>移情：发现商机、发现值得解决的问题</h3><h4 id="理解市场（潜力和规模）、最小可行化产品"><a href="#理解市场（潜力和规模）、最小可行化产品" class="headerlink" title="理解市场（潜力和规模）、最小可行化产品"></a>理解市场（潜力和规模）、最小可行化产品</h4><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>发现问题、访谈、问卷调查、测试验证（最小可行化）</p><h4 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h4><p>痛苦程度（打分机制）、新用户注册、社交覆盖、用户参与度</p><h3 id="黏性"><a href="#黏性" class="headerlink" title="黏性"></a>黏性</h3><h4 id="关键指标-1"><a href="#关键指标-1" class="headerlink" title="关键指标"></a>关键指标</h4><p>参与度、活跃用户、流失率、交互时间、回访率</p><h4 id="迭代、功能开发前七问"><a href="#迭代、功能开发前七问" class="headerlink" title="迭代、功能开发前七问"></a>迭代、功能开发前七问</h4><h3 id="病毒性：用户增长"><a href="#病毒性：用户增长" class="headerlink" title="病毒性：用户增长"></a>病毒性：用户增长</h3><h4 id="关键指标-2"><a href="#关键指标-2" class="headerlink" title="关键指标"></a>关键指标</h4><p>用户获取与增长、病毒式传播系数（&gt;1）、早起先行指标、活跃用户</p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>每位现有用户能够成功转化的新用户数</p><h4 id="三种病毒传播方式、黑客式营销"><a href="#三种病毒传播方式、黑客式营销" class="headerlink" title="三种病毒传播方式、黑客式营销"></a>三种病毒传播方式、黑客式营销</h4><h3 id="营收"><a href="#营收" class="headerlink" title="营收"></a>营收</h3><h4 id="关键指标-3"><a href="#关键指标-3" class="headerlink" title="关键指标"></a>关键指标</h4><p>平均每位客户营收、用户获取成本、流失率、客户终身价值、投资回报率、再发性营收</p><h4 id="找到营收点、市场——产品契合、收支平衡"><a href="#找到营收点、市场——产品契合、收支平衡" class="headerlink" title="找到营收点、市场——产品契合、收支平衡"></a>找到营收点、市场——产品契合、收支平衡</h4><h3 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h3><h4 id="关键指标-4"><a href="#关键指标-4" class="headerlink" title="关键指标"></a>关键指标</h4><p>渠道、地域、营销等客户获取回报<br>“三大xx”、在规模化阶段形成纪律</p><h2 id="指标数据准线"><a href="#指标数据准线" class="headerlink" title="指标数据准线"></a>指标数据准线</h2><ol><li>平均数不够好</li><li>增长率：不同阶段增长率不同，黏性和病毒性阶段增长率是活跃用户，营收阶段增长率主要关注营收</li><li>参与的访客数量</li><li>定价指标：关键在于基于用户敏感的测试</li><li>客户获取成本：少于终身价值的1/3</li><li>病毒性：病毒传播系数大于1</li><li>邮件查看率</li></ol><h1 id="一些摘抄"><a href="#一些摘抄" class="headerlink" title="一些摘抄"></a>一些摘抄</h1><ol><li>最小可行化产品并不会大规模生产，但却可以在短时间内以最低的成本帮你尽快测试自己的想法。</li><li>精益分析思维指提出正确的问题，并重点关注那项可达成你期望结果的关键指标。</li><li>想要让一款社区产品极速启动就需要相当高的用户参与度，更好的做法是：在一个更小的、更容易触及的目标市场中培养更多具有黏性的高活跃用户。</li><li>数据是假设检验的极佳工具，除非结合人类的反思，否则很难在产生新假设方面有建树。</li><li>在足以验证商业假设的前提下，选择尽可能少的指标作为日常跟踪的对象。（北极星指标）</li><li>弄清客户需求以及自己所处模式，才是电商创业最要紧的事。</li><li>双边市场面临一个特殊问题，即必须同时吸引买家和卖家，但归根到底是重点关注有钱的一方。通常是一方指的是买方，找到一群愿意花钱的人后，再找到一群愿意挣钱的人要容易得多。</li><li>复杂是产品的坟墓。</li><li>注重公司所处的创业阶段，是因为应关注指标在很大程度上受特定阶段的影响，过早的关注某指标或优化无关紧要的内容必然会导致失败。</li><li>过早追求用户增长是一种时间和金钱的浪费。</li><li>黑客式营销进程的关键在于你的早起先行指标，找到一个好的先行指标，并通过试验确定其对公司未来的影响，实属不易。</li><li>盈利三种基本策略：市场细分策略、低成本策略、差异化策略。</li><li>多数创业公司失败的原因：平均水平远远不够好。</li><li>关于定价，最大的一个误解是，你的产品或服务所定的价格与你开发和运营的成本直接相关。事实并不是这样。价格取决于你的顾客准备为它付多少钱。</li><li>精益分析不是要你抛弃直觉，它是要你验证你的直觉。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析-活用Pandas库读书笔记</title>
      <link href="2020/10/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9APython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%9A%E6%B4%BB%E7%94%A8Pandas%E5%BA%93/"/>
      <url>2020/10/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9APython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%9A%E6%B4%BB%E7%94%A8Pandas%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><strong><em>Python数据分析：活用Pandas库<br>[美] 丹尼尔·陈 / 武传海 / 人民邮电出版社 / 2020-2<br>豆瓣链接<a href="https://book.douban.com/subject/34973484/">https://book.douban.com/subject/34973484/</a></em></strong></p><h2 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h2><blockquote><p>这是本值得至少看两遍的pandas入门书籍，对新手很友好，内容上基本涵盖了初学者需要掌握的内容。对易错点和重点内容讲解也较细，是可以用作Pandas教材的一本书。唯一的不足是章节之间的组织逻辑还可以再优化。</p></blockquote><p><img src="https://i.loli.net/2020/11/18/XmOBb2FvjD8C1Pq.png" alt="活用Pandas库.png"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议学习笔记</title>
      <link href="2020/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>2020/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><strong><em>本文是阅读书籍《图解HTTP 彩色版》后，整理的有关HTTP基础知识点的笔记。</em></strong></p><h1 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h1><p>HTTP协议是Hypertext Transfer Protocol超文本传输协议的缩写。HTTP协议属于应用层协议，它构建在TCP和IP协议之上，处于TCP/IP体系架构中的顶端，使用TCP/IP协议来传输数据。<br><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/HTTP.png" alt="HTTP介绍.png"></p><h1 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h1><blockquote><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。<br>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，为了解决这个问题，引入cookie和session。</p></blockquote><h1 id="HTTP请求与响应过程"><a href="#HTTP请求与响应过程" class="headerlink" title="HTTP请求与响应过程"></a>HTTP请求与响应过程</h1><ol><li>浏览器根据所使用的HTTP协议，解析出url对应的域名；</li><li>通过DNS域名解析，查询出该域名对应的IP地址；</li><li>通过URL解析出对应的端口号，如果是80，默认可以省略；</li><li>浏览器根据ip和端口建立TCP连接；</li><li>浏览器向服务器发送一条HTTP请求报文，比如get请求；</li><li>服务器相应请求，并发送给浏览器返回报文；</li><li>浏览器渲染网页并关闭与服务器的连接</li></ol><h1 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h1><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/HTT2.png" alt="HTTP请求过程.png"></p><h2 id="第一部分：请求行：请求行分为三个部分：请求方法、请求地址和协议版本。"><a href="#第一部分：请求行：请求行分为三个部分：请求方法、请求地址和协议版本。" class="headerlink" title="第一部分：请求行：请求行分为三个部分：请求方法、请求地址和协议版本。"></a>第一部分：请求行：请求行分为三个部分：请求方法、请求地址和协议版本。</h2><p>请求方法：根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>response = requests.get(url,headers={“User-Agent”:user_agent})</p><blockquote><p>GET 请求指定的页面信息，并返回实体主体。<br>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>PUT 从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE 请求服务器删除指定的页面。<br>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS 允许客户端查看服务器的性能。<br>TRACE 回显服务器收到的请求，主要用于测试或诊断。</p></blockquote><p>协议版本：格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1。</p><h2 id="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息" class="headerlink" title="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"></a>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</h2><p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p><h2 id="第三部分：空行，请求头部后面的空行是必须的"><a href="#第三部分：空行，请求头部后面的空行是必须的" class="headerlink" title="第三部分：空行，请求头部后面的空行是必须的"></a>第三部分：空行，请求头部后面的空行是必须的</h2><p>即使第四部分的请求数据为空，也必须有空行。</p><h2 id="第四部分：请求数据也叫主体，可以添加任意的其他数据。"><a href="#第四部分：请求数据也叫主体，可以添加任意的其他数据。" class="headerlink" title="第四部分：请求数据也叫主体，可以添加任意的其他数据。"></a>第四部分：请求数据也叫主体，可以添加任意的其他数据。</h2><p>这个例子的请求数据为空。</p><p>POST请求例子，使用Charles抓取的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">request： POST / HTTP1.1&nbsp; # 第一部分：请求行，第一行明了是post请求，以及http1.1版本。</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)&nbsp;  #&nbsp; 第二部分：请求头部，第二行至第六行。</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">           # 第三部分：空行，第七行的空行。</span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley&nbsp;  #&nbsp; 第四部分：请求数据，第八行。</span><br></pre></td></tr></tbody></table></figure><h1 id="HTTP响应过程"><a href="#HTTP响应过程" class="headerlink" title="HTTP响应过程"></a>HTTP响应过程</h1><p><img src="https://raw.githubusercontent.com/TingtingHus/PicBed/main/pics/HTTP3.png" alt="HTTP响应过程.png"></p><p>状态行：<br>3部分组成，分别为：协议版本，状态码，状态码描述。<br>状态码： 状态代码为3位数字。<br>比如200表示响应成功，404表示请求的网页不存在，500表示服务器内部错误等。</p><p>例子</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK&nbsp; # 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT  # 第二部分：消息报头，用来说明客户端要使用的一些附加信息</span><br><span class="line">Content-Type: text/html; charset=UTF-8  # 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 第三部分：空行，消息报头后面的空行是必须的，空行后面的html部分为响应正文。</span><br><span class="line">&lt;html&gt;&nbsp; &nbsp; &nbsp;  # 第四部分：响应正文，服务器返回给客户端的文本信息。</span><br><span class="line">&nbsp; &nbsp; &nbsp; &lt;head&gt;&lt;/head&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &lt;body&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;!--body goes here--&gt;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h1><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.<br>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.<br>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。<br>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学-从数据到结论读书笔记</title>
      <link href="2020/09/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%AD%A6%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BB%93%E8%AE%BA/"/>
      <url>2020/09/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%AD%A6%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BB%93%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><strong><em>统计学 : 从数据到结论 (第4版)<br>吴喜之 / 中国统计出版社 / 2013-3-1<br>豆瓣链接<a href="https://book.douban.com/subject/24316364/">https://book.douban.com/subject/24316364/</a></em></strong></p><h2 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h2><blockquote><p>入门的话推荐看前六章就够了，概念讲得较基础和细致，可以打下比较好的统计学基础。遗憾的是，从回归和分类开始就有点一笔带过的意思，让人看得摸不着头脑，故不建议看后面几章。</p></blockquote><p><img src="https://i.loli.net/2020/11/09/yBGJZ7z9nSIxq4r.png" alt="统计学.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>京东平台数据化运营读书笔记</title>
      <link href="2020/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%AC%E4%B8%9C%E5%B9%B3%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%8C%96%E8%BF%90%E8%90%A5/"/>
      <url>2020/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%AC%E4%B8%9C%E5%B9%B3%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%8C%96%E8%BF%90%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<p><strong><em>京东平台数据化运营<br>数据创新组 著 / 电子工业出版社 / 2016-3<br>豆瓣链接<a href="https://book.douban.com/subject/26709062/">https://book.douban.com/subject/26709062/</a></em></strong></p><h1 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h1><blockquote><p>全书落脚点在“运营”二字，更精准的读者是商家和运营人员，内容围绕：销售额 = 流量 * 转化率 * 客单价展开，获取流量、提高转化率、提升客单价和复购率组织章节内容，又名《京东商家操作指南》以及《京东平台营销大法》。记录了不少案例，对电商引流、营销有学习需求的，可以一看。</p></blockquote><h1 id="简单笔记"><a href="#简单笔记" class="headerlink" title="简单笔记"></a>简单笔记</h1><h2 id="第一章-流量"><a href="#第一章-流量" class="headerlink" title="第一章 流量"></a>第一章 流量</h2><h3 id="基本公式：销售额-流量-转化率-客单价"><a href="#基本公式：销售额-流量-转化率-客单价" class="headerlink" title="基本公式：销售额 = 流量 * 转化率 * 客单价"></a>基本公式：销售额 = 流量 * 转化率 * 客单价</h3><p>当竞争越来越激烈的时候，精细化运营一定是一个必然的趋势。<br>流量的重要指标<br>衡量流量多寡：访客数、浏览量、访问次数<br>衡量流量质量：平均访问深度、平均停留时间、跳失率</p><p>访客数UV：同一用户在同一个统计时间窗口内从多个不同渠道多次访问只会被计算为一次<br>浏览量PV：同一用户多次浏览或刷新同一页面，浏览器累加<br>访问次数：同一用户在一个统计窗口内访问同一家店铺的次数<br>平均访问深度 = 浏览量 / 访问次数，衡量用户在一个店铺访问时，浏览了几个页面<br>平均停留时间 = 总停留时间 / 总浏览量<br>跳失率 = 跳出页次数 / 访问次数，衡量用户只访问店铺或商品一个页面就离开店铺的次数占总访问次数的比例</p><h3 id="流量的诊断"><a href="#流量的诊断" class="headerlink" title="流量的诊断"></a>流量的诊断</h3><p>第一步：稳定性<br>第二步：合理性：根据店铺的发展阶段不同，流量的大小和占比也不同，重点是要分析各个渠道的占比变化<br>第三步：成长性：流量来源分析、访客来源分析、成交来源分析</p><h2 id="第二章-转化率"><a href="#第二章-转化率" class="headerlink" title="第二章 转化率"></a>第二章 转化率</h2><p>成交转化率指标<br>静默转化率、咨询转化率、加购转化率、付款转化率</p><p>入店访客数<br>有效访客数<br>咨询访客数<br>加购访客数<br>订单访客数<br>成交访客数 ：下单的总客户数<br>成交转化率 = 成交客户数 / 访问客户数<br>静默转化率 = 静默成交的客户数 / 总静默客户数<br>咨询转化率 = 咨询成交客 / 总咨询访客数<br>加购转化率 = 成交访客数 / 点击加入购物车的访客<br>付款转化率 = 先款订单已付款订单 / 先款订单总下单量</p><h3 id="影响转化率的重要因素"><a href="#影响转化率的重要因素" class="headerlink" title="影响转化率的重要因素"></a>影响转化率的重要因素</h3><p>第一阶段：引流<br>精准优质的流量入口是成功的一半，即提高流量的精准度和相关度<br>第二阶段：售前、售中<br>店铺相关、商品相关、客服相关、物流相关、卖家原因、库存情况、竞品情况、售后保障体系<br>第三阶段：售后<br>发货、配送、收货、评价、售后</p><h3 id="六大关键步骤"><a href="#六大关键步骤" class="headerlink" title="六大关键步骤"></a>六大关键步骤</h3><p>流量来源是关键：流量从哪里来，搜索的关键字有哪些，每个关键字的转化率<br>承接好坏看页面：商品详情页的描述和布局，可以通过热力图查看用户的感兴趣点<br>用户选购拼商品<br>商品背后是服务<br>物流库存莫忽视<br>竞品动态要追踪：竞品是否有活动，价格波动</p><h3 id="转化率对比的四个维度"><a href="#转化率对比的四个维度" class="headerlink" title="转化率对比的四个维度"></a>转化率对比的四个维度</h3><p>行业优秀<br>行业相似<br>本店同期<br>本店上升</p><h3 id="寻找准化率低的原因"><a href="#寻找准化率低的原因" class="headerlink" title="寻找准化率低的原因"></a>寻找准化率低的原因</h3><p>1.找问题终端<br>2.找问题来源<br>3.找问题页面（热力图）<br>4.找问题商品（TOP流量商品追踪法、TOP销售商品追踪法、双TOP对比法）<br>5.找问题服务</p><h2 id="第三章-提升客单价"><a href="#第三章-提升客单价" class="headerlink" title="第三章 提升客单价"></a>第三章 提升客单价</h2><p>客单价 = 下单金额 / 下单用户数<br>客单件 = 下单件数 / 下单用户数</p><h3 id="商品分类"><a href="#商品分类" class="headerlink" title="商品分类"></a>商品分类</h3><p>1.常用款：以成本为导向的定价<br>2.引流款：价格降低，性价比高，主要是为了其它商品引流，因此要注意关联营销<br>3.利润款：在市场上具有优势，竞品较少，定价可以适当提高，是店铺的主要利润来源<br>4.活动款：可以在之前有较高定价，活动中降价，吸引用户<br>5.爆款：预热期的爆款定价可以偏低，发展期的爆款可以维持定价，增加利润，成熟期的爆款可以适当提高定价，衰退期的爆款价格可以适当降低<br>6.旗舰款：旗舰款的定位是高端人群，打造的是品牌效益，可以适当提高定价，追求利润<br>7.边缘款：可以进行适当的品牌包装或取舍</p><h3 id="如何提高客单价"><a href="#如何提高客单价" class="headerlink" title="如何提高客单价"></a>如何提高客单价</h3><p>一是打造爆款<br>二是进行关联营销：比如免邮、满减、满赠、套装<br>对于关联的商品主要有同类替代、异类相关、商品功能性互补、解决方案型互补、情感嫁接型、活动类目推广型</p><h2 id="第四章-增加复购率"><a href="#第四章-增加复购率" class="headerlink" title="第四章 增加复购率"></a>第四章 增加复购率</h2><p>做好用户关系维护，增加用户满意度，提高一定时间内用户的下单频率。<br>流量<br>客单价<br>转化率<br>复购率（说白了就是黏性，RFM中的F 频率）：用户复购率、订单复购率<br>评价率</p><p>会员回头率 = 回购的会员数 / 总购买客户数<br>新用户留存率 = 新用户留存数 / 新用户总数  （新用户留存数是指产生了成功交易的用户）</p><h3 id="影响复购率的因素"><a href="#影响复购率的因素" class="headerlink" title="影响复购率的因素"></a>影响复购率的因素</h3><p>1.商品质量<br>2.服务质量<br>3.物流满意度</p><h3 id="提升复购率的方法"><a href="#提升复购率的方法" class="headerlink" title="提升复购率的方法"></a>提升复购率的方法</h3><p>1.建立会员管理体制<br>2.巧用优惠券精准营销（根据渠道、消费行为）<br>3.赋予会员专享权益<br>4.会员娱乐式互动（签到、社群等）</p><h2 id="第五章-行业分析"><a href="#第五章-行业分析" class="headerlink" title="第五章 行业分析"></a>第五章 行业分析</h2><h3 id="用户心智模型"><a href="#用户心智模型" class="headerlink" title="用户心智模型"></a>用户心智模型</h3><p>1.只能接受有限的信息<br>2.喜欢简单，讨厌复杂<br>3.缺乏安全感<br>4.对品牌印象不会轻易改变<br>5.心智容易失去焦点</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谁说菜鸟不会数据分析读书笔记</title>
      <link href="2020/08/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%B0%81%E8%AF%B4%E8%8F%9C%E9%B8%9F%E4%B8%8D%E4%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>2020/08/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%B0%81%E8%AF%B4%E8%8F%9C%E9%B8%9F%E4%B8%8D%E4%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong><em>谁说菜鸟不会数据分析<br>张文霖、刘夏璐、狄松 编著 / 电子工业出版社 / 2011-7<br>豆瓣链接<a href="https://book.douban.com/subject/6434328/">https://book.douban.com/subject/6434328/</a></em></strong></p><h2 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h2><blockquote><p>难度是青铜级别，收益是钻石级别。整本书逻辑非常清晰，全程大白话，花一天时间就可以轻松看完。此书输出的技能是所有职场人士都应该具备的，而职业的数据分析早已超越这个难度，是大数据时代下要求更复杂的数据清洗、更深奥的高级算法、更深刻的业务价值，尽管如此，也不能否认这本书的普适价值。</p></blockquote><p><img src="https://i.loli.net/2020/11/04/W4pJumGHQs1SXew.png" alt="谁说菜鸟不会数据分析.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
